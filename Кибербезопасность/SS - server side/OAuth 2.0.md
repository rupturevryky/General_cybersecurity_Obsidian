## Что такое OAuth?

OAuth 2.0 — это **протокол делегированного доступа**, позволяющий приложениям получать ограниченный доступ к защищенным ресурсам пользователя без раскрытия его учетных данных.

>[!note] **Определение:** 
>Это **фреймворк авторизации**, а не аутентификации. Его цель — позволить приложению получать **ограниченный доступ** к ресурсам пользователя на другом сервисе, без раскрытия пароля пользователя.

**Как применяется:** Классический пример — "Войти через Facebook". Вы даёте стороннему приложению (например, Spotify) разрешение получить доступ к вашему списку друзей в Facebook или к вашему профилю. OAuth 2.0 управляет этим процессом делегирования прав. Пользователь аутентифицируется напрямую в Facebook (ресурсный сервер), который затем выдаёт приложению Spotify **токен доступа (Access Token)**. Spotify использует этот токен для вызова API Facebook от вашего имени.

> **Примечание**
>
> Хотя современным стандартом является OAuth 2.0, некоторые сайты всё ещё используют устаревшую версию 1a. OAuth 2.0 была написана с нуля, а не разработана напрямую на базе OAuth 1.0. В результате они сильно отличаются. Обратите внимание, что термин «OAuth» в этих материалах относится исключительно к OAuth 2.0.

---

# Как работает OAuth 2.0?

OAuth 2.0 изначально был разработан как способ совместного доступа к конкретным данным между приложениями. Он определяет серию взаимодействий между тремя сторонами: клиентским приложением, владельцем ресурса и провайдером OAuth.

- **Клиентское приложение** — сайт или веб-приложение, которое хочет получить доступ к данным пользователя.
- **Владелец ресурса** — пользователь, к данным которого клиентское приложение хочет получить доступ.
- **Провайдер услуг OAuth** — сайт или приложение, которое контролирует данные пользователя и доступ к ним. Они поддерживают OAuth, предоставляя API для взаимодействия как с сервером авторизации, так и с сервером ресурсов.

Существует множество различных способов реализации самого процесса OAuth. Они известны как OAuth «потоки (flows)» или «[[OAuth 2.0#Типы грантов (grant types) OAuth|grant types]]». Самыми распространёнными являются типах грантов: «authorization code» и «implicit». В широком смысле, оба типа грантов включают следующие этапы:

1. Клиентское приложение запрашивает доступ к подмножеству данных пользователя, указывая, какой тип гранта он хочет использовать и какой именно доступ.
2. Пользователю предлагается войти в сервис OAuth и явно дать согласие на запрошенный доступ.
3. Клиентское приложение получает уникальный токен доступа, подтверждающий, что у него есть разрешение пользователя на доступ к запрашиваемым данным. Точный способ этого процесса значительно зависит от типа гранта.
4. Клиентское приложение использует этот токен доступа для создания API-запросов, которые получают соответствующие данные с сервера ресурсов.

---

### Что такое тип гранта OAuth?

Тип гранта OAuth определяет точную последовательность шагов в процессе OAuth. Тип гранта также влияет на то, как клиентское приложение взаимодействует с сервисом OAuth на каждом этапе, включая передачу самого токена доступа. По этой причине типы грантов часто называют «потоками OAuth».

Сервис OAuth должен быть настроен для поддержки определённого типа гранта, прежде чем клиентское приложение сможет инициировать соответствующий поток. Клиентское приложение указывает, какой тип гранта оно хочет использовать в первоначальном запросе авторизации, отправляемом сервису OAuth.

Существует несколько различных типов грантов, каждый из которых имеет разный уровень сложности и соображений по вопросам безопасности. Мы сосредоточимся на типах «authorization code» и «implicit», так как они самые распространённые.

---
### OAuth scopes

Для любого типа гранта OAuth клиентское приложение должно указать, к каким данным оно хочет получить доступ и какие операции выполнять. Он делает это с помощью параметра `scope` запроса авторизации, который отправляется сервису OAuth. 

Базово, OAuth области (scopes), для которых клиентское приложение может запросить доступ, уникальны для каждого сервиса OAuth. Поскольку название области — это просто произвольная текстовая строка, формат может значительно различаться между поставщиками. Некоторые даже используют полноценный URI в качестве названия области, аналогично REST API endpoint. Например, при запросе доступа для чтения списка контактов пользователя имя области может принимать одну из следующих форм в зависимости от используемого сервиса OAuth:

```uri
scope=contacts
scope=contacts.read
scope=contact-list-r
scope=https://oauth-authorization-server.com/auth/scopes/user/contacts.readonly
```

Однако при использовании OAuth для аутентификации часто применяются стандартизированные области OpenID Connect. Например, область `openid profile` будет предоставлять клиентскому приложению доступ к заранее определённому набору базовой информации о пользователе, такой как его адрес электронной почты, имя пользователя и так далее. Подробнее о [[OAuth 2.0#OpenID Connect|OpenID Connect]] мы поговорим позже. 

---

## Тип гранта: Authorization code

Клиентское приложение и сервис OAuth сначала используют перенаправления для обмена серией браузерных HTTP-запросов, которые запускают этот поток. 
1. Пользователя спрашивают, согласен ли он с запрошенным доступом. 
2. Если он согласен, заявке клиента выдается «код авторизации». 
3. Клиентское приложение затем обменивается этим кодом с сервисом OAuth, чтобы получить «токен доступа», который можно использовать для вызовов API для получения соответствующих пользовательских данных.

Вся коммуникация, которая происходит после обмена кодом/токеном, отправляется от сервера к серверу по безопасному, предварительно настроенному обратному каналу и, следовательно, невидима для конечного пользователя. Этот безопасный канал устанавливается, когда клиентское приложение впервые регистрируется в службе OAuth. В это время также генерируется `client_secret`, который клиентское приложение должно использовать для аутентификации при отправке этих запросов от сервера к серверу.

Поскольку наиболее конфиденциальные данные (токен доступа и данные пользователя) не отправляются через браузер, этот тип предоставления прав, пожалуй, является самым безопасным. Серверные приложения в идеале должны всегда использовать этот тип предоставления прав, если это возможно.

![[Pasted image 20260131194819.png]]

---

#### 1. Запрос на авторизацию

Клиентское приложение отправляет запрос на конечную точку `/authorization` сервиса OAuth с просьбой получить разрешение на доступ к конкретным данным пользователей. Обратите внимание, что отображение конечных точек может различаться у разных поставщиков — лаборатории PortSwigger используют конечную точку `/auth` для этой цели. Однако вы всегда должны иметь возможность определить конечную точку по параметрам, использованным в запросе. 

```http
GET /authorization?client_id=12345&redirect_uri=https://client-app.com/callback&response_type=code&scope=openid%20profile&state=ae13d489bd00e3c24 HTTP/1.1 
Host: oauth-authorization-server.com
```

Этот запрос обычно содержит следующие примечательные параметры:

1. `client_id`
   
   > Обязательный параметр, содержащий уникальный идентификатор клиентского приложения. Это значение генерируется, когда клиентское приложение регистрируется в сервисе OAuth.
   > 
1. `redirect_uri`
   
   > URI, на который следует перенаправлять браузер пользователя при отправке кода авторизации клиентскому приложению. Это также известно как «callback URI» или «callback endpoint». Многие атаки на OAuth основаны на использовании недостатков в валидации этого параметра.
   > 
1. `response_type`
   
   > Определяет, какой тип гранта ожидает клиентское приложение и, следовательно, какой поток оно хочет инициировать. Для типа выдачи гранта "Authorization code" значение должно быть `code`. 
   > 
1. `scope`
   
   > Используется для указания, к какому подмножеству данных пользователя клиентское приложение хочет получить доступ. Обратите внимание, что это могут быть пользовательские области, заданные провайдером OAuth, или стандартизированные области, определённые спецификацией [[OAuth 2.0#OpenID Connect|OpenID Connect]].
   > 
1. `state`
   
   > Сохраняет уникальное, непредсказуемое значение, привязанное к текущей сессии в клиентском приложении. Сервис OAuth должен вернуть это же значение в ответе вместе с кодом авторизации. Этот параметр служит формой CSRF-токена для клиентского приложения, гарантируя, что запрос к конечной точке `/callback` исходит от того же человека, который инициировал поток OAuth. 

---

#### 2. Вход пользователя и согласие

Когда сервер авторизации получает первоначальный запрос, он перенаправляет пользователя на страницу входа, где ему будет предложено войти в свой аккаунт у провайдера OAuth. Например, это часто их аккаунт в социальных сетях.

Затем пользователю будет представлен список данных, к которым клиентское приложение хочет получить доступ. Это основано на параметре `scope`, определённом в запросе авторизации. Пользователь может выбрать, давать согласие на этот доступ или нет.

Важно отметить, что после того как пользователь одобрил определённый `scope` для клиентского приложения, этот шаг будет выполняться автоматически, если у пользователя осталась действительная сессия с сервисом OAuth. Другими словами, при первом выборе «Войти с помощью социальных сетей» пользователь должен войти вручную и дать согласие, но если позже он снова зайдёт в клиентское приложение, он часто сможет войти в систему одним кликом.

---

#### 3. Выдача кода авторизации

Если пользователь даёт согласие на запрошенный доступ, его браузер будет перенаправлен на конечную точку `/callback`, указанную в параметре `redirect_uri` запроса авторизации. В результате этот `GET` запрос будет содержать код авторизации в качестве query параметра. В зависимости от конфигурации, параметр `state` может также передаваться с тем же значением, что и в запросе авторизации. 

```http
GET /callback?code=a1b2c3d4e5f6g7h8&state=ae13d489bd00e3c24 HTTP/1.1 
Host: client-app.com
```

---

#### 4. Запрос токена доступа

После того как клиентское приложение получает код авторизации, ему необходимо обменять его на токен доступа. Для этого он отправляет server-to-server `POST` запрос на конечную точку `/token` сервиса OAuth. Вся коммуникация с этого момента происходит в защищённом бэк-канале и, следовательно, обычно не может быть замечена или контролироваться злоумышленниками. 

```http
POST /token HTTP/1.1 
Host: oauth-authorization-server.com 
… 
client_id=12345&client_secret=SECRET&redirect_uri=https://client-app.com/callback&grant_type=authorization_code&code=a1b2c3d4e5f6g7h8
```

Помимо `client_id` и `code` для авторизации, вы заметите следующие новые параметры: 

1. `client_secret`

> Клиентское приложение должно использовать `client_secret` для аутентификации, включив секретный ключ, назначенный ему при регистрации в сервисе OAuth.
> 
2. `grant_type`

> Использовался для того, чтобы новый конечный узел знал, какой тип гранта хочет использовать клиентское приложение. В этом случае `grant_type` должен быть установлен на `authorization_code`. 

---

#### 5. Предоставление токенов доступа

Сервис OAuth проверит запрос на токен доступа. Если всё соответствует ожиданиям, сервер ответит, предоставляя клиентскому приложению токен доступа с запрошенной областью действий.

```json
{
	"access_token": "z0y9x8w7v6u5",
	"token_type": "Bearer",
	"expires_in": 3600,
	"scope": "openid profile",
	…
}
```

---

#### 6. Вызов API

Теперь, когда клиентское приложение имеет код доступа, оно наконец может получать данные пользователя с сервера ресурсов. Для этого он совершает вызов API на конечную точку `/userinfo` сервиса OAuth. Токен доступа вводится в заголовок `Authorization: Bearer`, чтобы доказать, что клиентское приложение имеет разрешение на доступ к этим данным. 

```http
GET /userinfo HTTP/1.1 
Host: oauth-resource-server.com 
Authorization: Bearer z0y9x8w7v6u5
```

---

#### 7. Грант ресурсов

Сервер ресурсов должен проверить, что токен валиден и принадлежит текущему клиентскому приложению. Если да, то он ответит, отправив запрошенный ресурс, то есть данные пользователя, исходя из объёма токена доступа.

```json
{
	"username":"carlos",
	"email":"carlos@carlos-montoya.net",
	…
}
```

Клиентское приложение наконец может использовать эти данные по назначению. В случае аутентификации OAuth она обычно используется как идентификатор для получения аутентифицированной сессии, фактически входя в систему.

---

## Тип гранта: Implicit (неявный)

Неявный тип гранта гораздо проще. Вместо того чтобы сначала получить код авторизации и затем обменять его на токен доступа, клиентское приложение получает токен доступа сразу после согласия пользователя.

Возможно, вы задаётесь вопросом, почему клиентские приложения не всегда используют неявный тип гранта. Ответ относительно прост — это гораздо менее безопасно. При использовании неявного гранта вся коммуникация происходит через перенаправления браузера — нет защищённого обратного канала, как в потоке авторизационного кода. Это означает, что чувствительный токен доступа и данные пользователя более подвержены потенциальным атакам.

Неявный тип гранта больше подходит для одностраничных приложений и нативных настольных приложений, которые не могут хранить `client_secret` на сервере и, следовательно, не получают больших преимуществ от использования типа "Authorization code". 

![[Pasted image 20260131202051.png]]

---

#### 1. Запрос на авторизацию

Неявный поток начинается примерно так же, как и поток авторизационного кода. Единственное существенное отличие в том, что параметр `response_type` должен быть установлен в `token`. 

```http
GET /authorization?client_id=12345&redirect_uri=https://client-app.com/callback&response_type=token&scope=openid%20profile&state=ae13d489bd00e3c24 HTTP/1.1 
Host: oauth-authorization-server.com
```

---

#### 2. Вход пользователя и согласие

Пользователь входит в систему и решает, давать ли согласие на запрошенные разрешения или нет. Этот процесс точно такой же, как и для потока авторизационного кода.

---

#### 3. Предоставление токена доступа

Если пользователь дает согласие на запрошенный доступ, здесь начинаются различия. Сервис OAuth перенаправит браузер пользователя на `redirect_uri`, указанный в запросе на авторизацию. Однако вместо отправки query-параметра, содержащего код авторизации, он отправит токен доступа и другие данные, относящиеся к токену, в виде фрагмента URL.

```http
GET /callback#access_token=z0y9x8w7v6u5&token_type=Bearer&expires_in=5000&scope=openid%20profile&state=ae13d489bd00e3c24 HTTP/1.1 
Host: client-app.com
```

Поскольку токен доступа отправляется в виде фрагмента URL, он никогда не отправляется напрямую в клиентское приложение. Вместо этого клиентское приложение должно использовать подходящий скрипт для извлечения фрагмента и его сохранения.

---

#### 4. Вызов API

После того как клиентское приложение успешно извлекло токен доступа из фрагмента URL, оно может использовать его для вызовов API на конечную точку `/userinfo` сервиса OAuth. В отличие от потока кода авторизации, это также происходит через браузер. 

```http
GET /userinfo HTTP/1.1 
Host: oauth-resource-server.com
Authorization: Bearer z0y9x8w7v6u5
```

---

#### 5. Грант ресурсов

Сервер ресурсов должен проверить, что токен валиден и принадлежит текущему клиентскому приложению. Если да, то он ответит, отправив запрошенный ресурс, то есть данные пользователя на основе `scope`, связанного с токеном доступа.

```json
{
	"username":"carlos",
	"email":"carlos@carlos-montoya.net"
}
```

Клиентское приложение наконец может использовать эти данные по назначению. В случае аутентификации OAuth она обычно используется как идентификатор для получения аутентифицированной сессии, фактически входя в систему.

---

## OAuth аутентификация

Хотя изначально OAuth не предназначался для этой цели, он также превратился в средство аутентификации пользователей. 

Для механизмов аутентификации OAuth базовые потоки OAuth в основном остаются прежними; Главное отличие — в том, как клиентское приложение использует полученные данные. С точки зрения конечного пользователя, результат аутентификации OAuth в целом напоминает систему единого входа (SSO) на основе SAML. В этих материалах мы сосредоточимся исключительно на уязвимостях в этом похожем на SSO сценарий.

Аутентификация OAuth обычно реализуется следующим образом:

1. Пользователь выбирает опцию входа через свой аккаунт в соцсетях. Клиентское приложение затем использует сервис OAuth социальной сети для запроса доступа к некоторым данным, которые можно использовать для идентификации пользователя. Например, это может быть адрес электронной почты, зарегистрированный в их аккаунте.
2. После получения токена доступа клиентское приложение запрашивает эти данные у сервера ресурсов, обычно с выделенной конечной точки `/userinfo`. 
3. После получения данных клиентское приложение использует их вместо имени пользователя для входа пользователя. Токен доступа, полученный от сервера авторизации, часто используется вместо традиционного пароля.

---

# OpenID Connect

---

# Лабораторные

---

## Lab: Authentication bypass via OAuth implicit flow

https://portswigger.net/web-security/oauth/lab-oauth-authentication-bypass-via-oauth-implicit-flow