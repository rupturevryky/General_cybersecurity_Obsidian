# Введение в "HTTP request smuggling"

---

## Что такое контрабанда HTTP-запросов?

**Контрабанда HTTP-запросов (HTTP request smuggling)** — это метод вмешательства в процесс обработки веб-сайтом последовательностей HTTP-запросов, полученных от одного или нескольких пользователей. Уязвимости, связанные с контрабандой запросов, часто носят критический характер, позволяя злоумышленнику обойти средства контроля безопасности, получить несанкционированный доступ к конфиденциальным данным и напрямую скомпрометировать других пользователей приложения.

Контрабанда запросов в основном связана с запросами HTTP/1. Однако веб-сайты, поддерживающие HTTP/2, могут быть уязвимы в зависимости от их бэкэнд-архитектуры.

> [!info] Исследования PortSwigger
> 
> Контрабанда HTTP-запросов была впервые задокументирована в 2005 году и вновь стала популярной благодаря обширным исследованиям PortSwigger по этой теме. Подробности см. в следующих технических документах:
> - [Атаки HTTP-десинхронизации: возрождение контрабанды запросов](https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn)
> - [HTTP/2: продолжение всегда хуже](https://portswigger.net/research/http2)
> - [Атаки десинхронизации с помощью браузера: новая граница в контрабанде HTTP-запросов](https://portswigger.net/research/browser-powered-desync-attacks)

---

## Что происходит при атаке с контрабандой HTTP-запросов?
Современные веб-приложения часто используют цепочки HTTP-серверов между пользователями и конечной логикой приложения. Пользователи отправляют запросы на фронт-энд сервер (иногда называемый балансировщиком нагрузки или обратным прокси), и этот сервер пересылает запросы на один или несколько бэк-энд серверов. Такой тип архитектуры становится все более распространенным и в некоторых случаях неизбежным в современных облачных приложениях.

Когда фронтальный сервер пересылает HTTP-запросы на бэкэнд-сервер, он обычно отправляет несколько запросов по одному и тому же сетевому соединению бэкэнда, поскольку это гораздо более эффективно и производительно. Протокол очень прост: HTTP-запросы отправляются один за другим, и принимающий сервер должен определить, где заканчивается один запрос и начинается следующий:

![[Pasted image 20260222171037.png]]

В этой ситуации крайне важно, чтобы фронт-энд и бэк-энд системы согласовали границы между запросами. В противном случае злоумышленник может отправить неоднозначный запрос, который будет по-разному интерпретирован фронт-энд и бэк-энд системами:

![[Pasted image 20260222171102.png]]

В этом случае злоумышленник заставляет бэкэнд-сервер интерпретировать часть своего фронтэнд-запроса как начало следующего запроса. Он фактически добавляется к следующему запросу и может повлиять на то, как приложение обрабатывает этот запрос. Это атака типа «контрабанда запросов», которая может иметь разрушительные последствия.

---

## Как возникают уязвимости, связанные с контрабандой HTTP-запросов?

Большинство уязвимостей, связанных с контрабандой HTTP-запросов, возникают из-за того, что спецификация HTTP/1 предусматривает два разных способа указания места окончания запроса: заголовок Content-Length и заголовок Transfer-Encoding.

Заголовок Content-Length прост: он указывает длину тела сообщения в байтах. Например:

```http
POST /search HTTP/1.1
Host: normal-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 11

q=smuggling
```

Заголовок Transfer-Encoding можно использовать для указания того, что тело сообщения использует кодировку chunked. Это означает, что тело сообщения содержит один или несколько фрагментов данных. Каждый фрагмент состоит из размера фрагмента в байтах (выраженного в шестнадцатеричном формате), за которым следует символ новой строки, а затем — содержимое фрагмента. Сообщение заканчивается фрагментом размером ноль. Например:

```http
POST /search HTTP/1.1 
Host: normal-website.com 
Content-Type: application/x-www-form-urlencoded 
Transfer-Encoding: chunked

b
q=smuggling
0
```

>**Примечание:**
>
> Многие тестировщики безопасности не знают, что в HTTP-запросах можно использовать кодирование chunked по двум причинам:
> - Burp Suite автоматически распаковывает кодирование chunked, чтобы упростить просмотр и редактирование сообщений.
> - Браузеры обычно не используют кодирование по частям в запросах, и обычно оно встречается только в ответах сервера.

Поскольку спецификация HTTP/1 предоставляет два разных метода для указания длины HTTP-сообщений, одно сообщение может использовать оба метода одновременно, что приводит к их конфликту. Спецификация пытается предотвратить эту проблему, указывая, что если присутствуют оба заголовка `Content-Length` и `Transfer-Encoding`, то заголовок `Content-Length` должен игнорироваться. Это может быть достаточно для предотвращения неоднозначности, когда задействован только один сервер, но не когда два или более серверов соединены между собой. В этой ситуации могут возникнуть проблемы по двум причинам:

- Некоторые серверы не поддерживают заголовок `Transfer-Encoding` в запросах.
- Некоторые серверы, которые поддерживают заголовок `Transfer-Encoding`, могут быть вынуждены не обрабатывать его, если заголовок каким-либо образом запутывается.

Если фронт-энд и бэк-энд серверы ведут себя по-разному в отношении (возможно запутанного) заголовка Transfer-Encoding, то они могут не соглашаться по поводу границ между последовательными запросами, что приводит к уязвимостям, связанным с контрабандой запросов.

> **Примечание:**
> 
> Веб-сайты, которые используют HTTP/2 от начала до конца, по своей сути не подвержены атакам типа «smuggling». Поскольку спецификация HTTP/2 вводит единый надежный механизм для указания длины запроса, у злоумышленника нет возможности внести необходимую неоднозначность.
> 
> Однако многие веб-сайты имеют фронтенд сервер, поддерживающий HTTP/2, но развертывают его перед бэкэнд-инфраструктурой, которая поддерживает только HTTP/1. Это означает, что фронтенд сервер фактически должен преобразовывать получаемые запросы в HTTP/1. Этот процесс известен как понижение версии HTTP. Дополнительные сведения см. в разделе «[Расширенная контрабанда запросов](https://portswigger.net/web-security/request-smuggling/advanced)».

---

# Как выполнить атаку HTTP-контрабанды запросов

Классические атаки контрабанды запросов включают в себя размещение заголовков `Content-Length` и `Transfer-Encoding` в одном HTTP/1-запросе и манипулирование ими таким образом, чтобы фронт-энд и бэк-энд серверы обрабатывали запрос по-разному. Точный способ выполнения этого зависит от поведения двух серверов:

1. CL.TE: фронт-энд сервер использует заголовок `Content-Length`, а бэк-энд сервер использует заголовок `Transfer-Encoding`.
2. TE.CL: фронт-энд сервер использует заголовок `Transfer-Encoding`, а бэк-энд сервер использует заголовок `Content-Length`.
3. TE.TE: фронт-энд и бэк-энд серверы поддерживают заголовок `Transfer-Encoding`, но один из серверов может быть вынужден не обрабатывать его путем некоторого запутывания заголовка.

> [!warning] Примечание
> 
> Эти методы доступны только при использовании запросов HTTP/1. Браузеры и другие клиенты, включая Burp, по умолчанию используют HTTP/2 для связи с серверами, которые явно объявляют о его поддержке во время TLS-рукопожатия.
> 
> В результате при тестировании сайтов с поддержкой HTTP/2 необходимо вручную переключать протоколы в Burp Repeater. Это можно сделать в разделе **«Request attributes»** панели **«Inspector»**.

---

