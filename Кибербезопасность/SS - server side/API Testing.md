## API Recon

Чтобы начать тестирование API, сначала нужно узнать как можно больше информации о API, чтобы выявить поверхность его атаки.

Для начала нужно определить конечные точки API. Это места, где API получает запросы о конкретном ресурсе на своём сервере. Например, рассмотрим следующий `GET` запрос: 

```http
GET /api/books HTTP/1.1 
Host: example.com
```

Конечная точка API для этого запроса — `/api/books`. Это приводит к взаимодействию с API для получения списка книг из библиотеки. Другой API-конечный пункт может быть, например, `/api/books/mystery`, который извлекает список детективных книг. 

После того как вы определили конечные точки, нужно понять, как с ними взаимодействовать. Например, вы должны узнать информацию о следующем:

- Входные данные, которые API обрабатывает, включая как обязательные, так и необязательные параметры.
- Типы запросов, которые принимает API, включая поддерживаемые методы HTTP и медиаформаты.
- Ограничения скорости и механизмы аутентификации.

---

## Документация API

API обычно документируются, чтобы разработчики знали, как ими пользоваться и с ними интегрироваться.

Документация может быть как в виде читаемой для человека, так и в машиночитаемой форме. Читаемая человеком документация разработана для разработчиков, чтобы они могли понять, как пользоваться API. Он может включать подробные объяснения, примеры и сценарии использования. Машиночитаемая документация разработана для обработки программным обеспечением для автоматизации задач, таких как интеграция и валидация API. Он написан в структурированных форматах, таких как JSON или XML.

Документация API часто доступна публично, особенно если API предназначен для использования внешними разработчиками. Если это так, всегда начинайте разведку с изучения документации.

---

## Обнаружение документации API

Даже если документация по API не доступна открыто, вы всё равно можете получить к ней доступ, просматривая приложения, использующие API.

Для этого можно использовать Burp Scanner для сканирования API. Вы также можете вручную просматривать приложения через браузер Burp. Ищите конечные точки, которые могут относиться к документации API, например:

- `/api`
- `/swagger/index.html`
- `/openapi.json`

Если вы определили конечную точку для ресурса, обязательно изучите базовый путь. Например, если вы определили конечную точку ресурса `/api/swagger/v1/users/123`, то следует исследовать следующие пути: 

- `/api/swagger/v1`
- `/api/swagger`
- `/api`

Также можно использовать список распространённых путей, чтобы найти документацию через Intruder.

---

## Использование машиночитаемой документации

Вы можете использовать различные автоматизированные инструменты для анализа любой машиночитаемой документации API, которую найдете.

Вы можете использовать Burp Scanner для сканирования и аудита документации OpenAPI или любой другой документации в формате JSON или YAML. Вы также можете парсировать документацию OpenAPI с помощью парсера OpenAPI BApp.

Вы также можете использовать специализированный инструмент для тестирования задокументированных конечных точек, например Postman или SoapUI.

---

## Поиск скрытых параметров

Когда вы занимаетесь разведкой API, вы можете найти недокументированные параметры, которые поддерживает API. Вы можете попытаться использовать их для изменения поведения приложения. Burp включает множество инструментов, которые помогут выявить скрытые параметры:

- Burp Intruder позволяет автоматически обнаруживать скрытые параметры, используя список слов с распространёнными именами параметров для замены существующих или добавления новых параметров. Обязательно указывайте имена, релевантные для заявки, исходя из вашей первоначальной разведки.
- Param miner BApp позволяет автоматически угадывать до 65 536 имён параметров за один запрос. Параметрический майнер автоматически угадывает имена релевантных приложению на основе информации, взятой из области применения.
- Инструмент обнаружения контента позволяет находить контент, не связанный с видимым контентом и который можно просматривать, включая параметры.

Вы также можете использовать BApp Backslash Powered Scanner BApp для выявления уязвимостей инъекций на стороне сервера. Сканер классифицирует входы как скучные, интересные или уязвимые. Вам нужно будет изучить интересные вводные данные, используя приведённые выше методы. Для получения дополнительной информации см. обратную черту Powered Scanning: белая книга по классам охоты на неизвестные уязвимости.

---

### Выявление скрытых параметров

Поскольку присвоение массы создаёт параметры из полей объектов, часто можно определить эти скрытые параметры, вручную проверяя объекты, возвращаемые API.

Например, рассмотрим запрос `PATCH /api/users/` позволяет пользователям обновлять имя пользователя и электронную почту, и включает следующий JSON: 

`{ "username": "wiener", "email": "wiener@example.com", }`

Параллельный запрос `GET /api/users/123` возвращает следующий JSON: 

`{ "id": 123, "name": "John Doe", "email": "john@example.com", "isAdmin": "false" }`

Это может указывать на то, что скрытые параметры `id` и `isAdmin` связаны с внутренним объектом пользователя, наряду с обновленными именем пользователя и параметрами электронной почты. 

---

### Тестирование уязвимостей массового распределения

Чтобы проверить, можно ли изменить перечисленное значение параметра `isAdmin`, добавьте его в `PATCH` запрос: 

`{ "username": "wiener", "email": "wiener@example.com", "isAdmin": false, }`

Кроме того, отправьте запрос `PATCH` с недопустимым значением параметра `isAdmin`: 

`{ "username": "wiener", "email": "wiener@example.com", "isAdmin": "foo", }`

Если приложение ведёт себя иначе, это может означать, что недействительное значение влияет на логику запроса, но допустимое значение — нет. Это может указывать на успешное обновление параметра пользователем.

Затем вы можете отправить запрос `PATCH` с установленным значением параметра `isAdmin` в `true`, чтобы попытаться воспользоваться уязвимостью: 

`{ "username": "wiener", "email": "wiener@example.com", "isAdmin": true, }`

Если значение `isAdmin` в запросе привязано к пользовательскому объекту без надлежащей проверки и очистки, пользователю `wiener` могут быть неправильно предоставлены права администратора. Чтобы определить, верно ли это, просмотрите приложение и проверите, есть ли  у `wiener` доступ к административным функциям. 

---

## Тестирование на загрязнение параметров сервера в строке запроса

Чтобы проверить загрязнение серверных параметров в строке запроса, вставьте синтаксические символы запроса, такие как `#`,`=`, и `&` в свой вход и наблюдайте, как приложение реагирует. 

Рассмотрите уязвимое приложение, которое позволяет искать других пользователей по их имени пользователя. При поиске пользователя ваш браузер делает следующий запрос:

`GET /userSearch?name=peter&back=/home`

Для получения пользовательской информации сервер запрашивает внутренний API со следующим запросом:

`GET /users/search?name=peter&publicProfile=true`

---

### Усечение строк запросов

Вы можете использовать символ `#`, закодированный по URL, чтобы попытаться урезать серверный запрос. Чтобы лучше интерпретировать ответ, можно добавить строку после символа `#`. 

Например, вы можете изменить строку запроса на следующее:

`GET /userSearch?name=peter%23foo&back=/home`

Фронтенд попытается получить доступ к следующему URL:

`GET /users/search?name=peter#foo&publicProfile=true`

#### Примечание

Очень важно закодировать `#` по URL. В противном случае фронтенд-приложение интерпретирует его как идентификатор фрагмента, и он не будет передаваться внутреннему API. 

Прочитайте ответ на наличие подсказок о том, был ли запрос урезан. Например, если ответ возвращает пользователя `peter`, серверный запрос мог быть обрезан. Если возвращается сообщение об ошибке `Invalid name`, приложение могло считаться `foo` частью имени пользователя. Это говорит о том, что серверный запрос мог не быть усечен. 

Если вам удаётся урезать серверный запрос, это убирает необходимость устанавливать поле`publicProfile` в true. Возможно, вы сможете использовать это для возврата непубличных профилей пользователей. 

---

### Введение недопустимых параметров

Вы можете использовать символ `&`, закодированный URL, чтобы попытаться добавить второй параметр к серверному запросу. 

Например, вы можете изменить строку запроса на следующее:

`GET /userSearch?name=peter%26foo=xyz&back=/home`

Это приводит к следующему серверному запросу внутреннему API:

`GET /users/search?name=peter&foo=xyz&publicProfile=true`

Изучите ответ в поисках подсказок о том, как разобрался дополнительный параметр. Например, если ответ не изменился, это может указывать на успешное введение, но приложение проигнорировало.

Чтобы составить более полную картину, нужно будет провести дополнительные испытания.

---

### Введение допустимых параметров

Если вы сможете изменить строку запроса, вы можете попытаться добавить второй действительный параметр к серверному запросу.

#### Связанные страницы

Для информации о том, как определить параметры, которые можно внедрить в строку запроса, см. раздел «Скрытое поиски» раздел параметров.

Например, если вы определили параметр `email`, вы можете добавить его в строку запроса следующим образом: 

`GET /userSearch?name=peter%26email=foo&back=/home`

Это приводит к следующему серверному запросу внутреннему API:

`GET /users/search?name=peter&email=foo&publicProfile=true`

Изучите ответ в поисках подсказок о том, как разобрался дополнительный параметр.

---

### Переозначение существующих параметров

Чтобы убедиться, уязвимо ли приложение к загрязнению параметрами на стороне сервера, можно попробовать переопределить исходный параметр. Сделайте это, внедрив второй параметр с тем же именем.

Например, вы можете изменить строку запроса на следующее:

`GET /userSearch?name=peter%26name=carlos&back=/home`

Это приводит к следующему серверному запросу внутреннему API:

`GET /users/search?name=peter&name=carlos&publicProfile=true`

Внутренний API интерпретирует два параметра. Влияние этого зависит от того, как приложение обрабатывает второй параметр `name`. Это зависит от разных веб-технологий. Например: 

- PHP анализирует только последний параметр. Это приведёт к поиску пользователя по `carlos`.
- ASP.NET сочетает оба параметра. Это приведёт к поиску пользователя по `peter,carlos`, что может привести к ошибке `Invalid username`.
- Node.js / express анализирует только первый параметр. Это приводило к поиску пользователя по `peter`, давая неизменный результат.

Если вы сможете переопределить исходный параметр, возможно, вы сможете выполнить эксплойт. Например, вы можете добавить что-то в запрос. Это может позволить вам войти в систему как администратор `name=administrator`. 

---

## Тестирование на загрязнение параметров на стороне сервера в REST путях

API RESTful может размещать имена и значения параметров в пути URL, а не в строке запроса. Например, рассмотрим следующий путь:

```
/api/users/123
```

Путь URL можно разбить следующим образом:

- `/api` — это корневая конечная точка API.
- `/users` представляет собой ресурс, в данном случае `users`.
- `/123` представляет собой параметр, здесь — идентификатор конкретного пользователя.

Рассмотрите приложение, которое позволяет редактировать профили пользователей на основе их имени пользователя. Запросы отправляются на следующий конечный пункт:

```http
GET /edit_profile.php?name=peter
```

Это приводит к следующему серверному запросу:

```http
GET /api/private/users/peter
```

Злоумышленник может управлять параметрами URL-пути на стороне сервера для эксплуатации API. Для проверки этой уязвимости добавьте последовательности обхода путей для изменения параметров и наблюдения за реакцией приложения.

Вы можете отправить `peter/../admin` значение параметра `name`, закодированное URL: 

```http
GET /edit_profile.php?name=peter%2f..%2fadmin
```

Это может привести к следующему серверному запросу:

```http
GET /api/private/users/peter/../admin
```

Если серверный клиент или серверный API нормализуют этот путь, он может быть разрешен на `/api/private/users/admin`.

---

### Тестирование на загрязнение параметров со стороны сервера в структурированных форматах данных

Злоумышленник может управлять параметрами для эксплуатации уязвимостей при обработке сервером других структурированных форматов данных, таких как JSON или XML. Чтобы проверить это, внедрите неожиданные структурированные данные в пользовательские вводы и посмотрите, как сервер реагирует.

Рассмотрим приложение, которое позволяет пользователям редактировать свой профиль, а затем применять изменения с помощью запроса к серверному API. Когда вы редактируете своё имя, ваш браузер делает следующий запрос:

```http
POST /myaccount 

name=peter
```

Это приводит к следующему серверному запросу:

```http
PATCH /users/7312/update 

{"name":"peter"}
```

Вы можете попытаться добавить параметр `access_level` в запрос следующим образом: 

```http
POST /myaccount 

name=peter","access_level":"administrator
```

Если пользовательский ввод добавляется к серверным JSON-данным без надлежащей проверки или очистки, это приводит к следующему серверному запросу:

```http
PATCH /users/7312/update 

{name="peter","access_level":"administrator"}
```

Это может привести к предоставлению администраторского доступа `peter`
 
> **Связанные страницы**
> 
> Для информации о том, как определить параметры, которые можно внедрить в строку запроса, см. раздел «Finding hidden parameters».

Рассмотрим похожий пример, но когда клиентский ввод находится в данных JSON. Когда вы редактируете своё имя, ваш браузер делает следующий запрос:

```http
POST /myaccount 

{"name": "peter"}
```

Это приводит к следующему серверному запросу:

```http
PATCH /users/7312/update 

{"name":"peter"}
```

Вы можете попытаться добавить параметр `access_level` в запрос следующим образом: 

```http
POST /myaccount 

{"name": "peter\",\"access_level\":\"administrator"}
```

Если пользовательский ввод декодируется и затем добавляется к серверным JSON-данным без надлежащего кодирования, это приводит к следующему серверному запросу:

```http
PATCH /users/7312/update 

{"name":"peter","access_level":"administrator"}
```

Опять же, это может привести к предоставлению администраторского доступа `peter`. 

Структурированное форматирование также может происходить в ответах. Например, это может произойти, если пользовательский ввод надежно хранится в базе данных, а затем встроен в JSON-ответ через бэкенд-API без адекватного кодирования. Обычно вы можете обнаружить и использовать структурированное форматирование в ответах так же, как и в запросах.

> **Примечание**
> 
> Приведённый ниже пример в JSON, но загрязнение параметрами на стороне сервера может происходить в любом структурированном формате данных. Для примера в XML см. Раздел "XML external entity (XXE) injection".

---

# Лабораторные

---
## Lab: Exploiting an API endpoint using documentation

Здесь достаточно открыть страницу `/api/` и в соответствии с ней вызвать метод 

```
DELETE /api/user/carlos HTTP/2
Host: ...
```

---

## Lab: Finding and exploiting an unused API endpoint

Здесь после авторизации нужно обратить внимание на эндпоинт `GET /api/products/1/price`.

Его можно изменить на `OPTIONS` и узнать, что доступны метода `GET` и `PATCH`.

Конечный пэйлоад:
```
PATCH /api/products/1/price HTTP/2
Host: ...
Cookie: session=...
Content-Type: application/json
Content-Length: 14

{
	"price": 0
}
```

---

## Lab: Exploiting server-side parameter pollution in a query string

[Тестирование API - PortSwigger](https://portswigger.net/web-security/learning-paths/api-testing/api-testing-testing-for-server-side-parameter-pollution-in-the-query-string/api-testing/server-side-parameter-pollution/lab-exploiting-server-side-parameter-pollution-in-query-string)

1. В браузере Burp осуществите сброс пароля для пользователя `administrator`. 
2. **В истории Proxy > HTTP** обратите внимание на запрос `POST /forgot-password` и соответствующий JavaScript-файл `/static/js/forgotPassword.js`. 
3. Кликните правой кнопкой мыши по запросу `POST /forgot-password` и выберите **Отправить в Ретранслятор**. 
4. Во вкладке **Repeater** отправьте запрос повторно, чтобы убедиться, что ответ согласован.
5. Измените значение параметра `username=administrator` из на недопустимое имя пользователя, например `administratorx`. Отправьте запрос. Обратите внимание, что это приводит к появлению сообщения об ошибке `Invalid username`. 
6. Попытайтесь добавить вторую пару параметр-значение к серверному запросу с помощью символа `&`, закодированного по URL. Например, добавьте URL-кодированное `&x=y`:  
	 ```
	username=administrator%26x=y
	```
	Отправьте запрос. Обратите внимание, что это возвращает сообщение об ошибке `Parameter is not supported`. Это говорит о том, что внутренний API мог интерпретироваться как отдельный параметр `&x=y`, а не как часть имени пользователя. 
7. Попытка обрезать серверную строку запроса с помощью символа `#`, закодированного URL: 
    ```
    username=administrator%23
    ```
    Отправьте запрос. Обратите внимание, что это возвращает сообщение об ошибке `Field not specified`. Это говорит о том, что серверный запрос может включать дополнительный параметр под названием`field`, который был удалён символом `#`. 
8. Добавьте параметр `field` с недействительным значением в запрос `&field=x#`. Урежьте строку запроса после добавленной пары параметр-значение. Например, добавьте URL-кодированное : 
    ```
    username=administrator%26field=x%23
    ```
    Отправьте запрос. Обратите внимание, что это приводит к появлению сообщения об ошибке `Invalid field`. Это говорит о том, что серверное приложение может распознавать введённый параметр поля. 
9. Брут-форс определяет значение параметра `field`: 
    1. Кликните правой кнопкой мыши по запросу `POST /forgot-password` и выберите **«Отправить в intruder**».
    2. Во вкладке **Intruder** добавьте позицию полезной нагрузки к значению параметра`field`  следующим образом:
        ```
        username=administrator%26field=§x§%23
        ```
    3. В боковой панели **«Полезные нагрузки**» в **разделе «Конфигурация полезной нагрузки**» нажмите «**Добавить из списка**». Выберите встроенный список **Server-side variable names**, затем запускайте атаку.
    4. Ознакомьтесь с результатами. Обратите внимание, что запросы с именем пользователя и электронной почтой оба возвращают ответ `200`.
10. Изменим значение параметра `field` с `x#` на `email`: 
    ```
    username=administrator%26field=email%23
    ```
    Отправьте запрос. Обратите внимание, что запрос возвращает исходный ответ. Это говорит о том, что тип поля `email` является допустимым. 
11. В **истории Proxy > HTTP** просмотрите JavaScript-файл. Обратите внимание на конечную точку сброса пароля `/static/js/forgotPassword.js`, которая относится к параметру `reset_token`: 
    ```
    /forgot-password?reset_token=${resetToken}
    ```
12. Во вкладке **Repeater** измените значение параметра `field` с `email` на `reset_token`: 
    ```
    username=administrator%26field=reset_token%23
    ```
    Отправьте запрос. Обратите внимание, что это возвращает токен сброса пароля. Запишите это.
13. В браузере Burp введите конечную точку сброса пароля в адресную строку. Добавьте токен сброса пароля как значение параметра `reset_token`. Например: 
    ```
    /forgot-password?reset_token=123456789
    ```
14. Установите новый пароль.
15. Войдите в систему как пользователь `administrator`, используя свой пароль. 
16. Зайдите в **панель администратора** и удалите `carlos`, чтобы решить лабораторную задачу. 

---

# Предотвращение уязвимостей в API

При проектировании API обязательно учитывайте безопасность с самого начала. В частности, убедитесь, что вы:

- Защитите свою документацию, если не планируете, чтобы ваш API был общедоступен.
- Убедитесь, что ваша документация актуальна, чтобы легитимные тестировщики имели полную видимость атак API поверхностно.
- Примените список разрешенных HTTP-методов.
- Проверьте, что тип контента ожидается для каждого запроса или ответа.
- Используйте общие сообщения об ошибках, чтобы не раскрывать информацию, которая может быть полезна злоумышленникам.
- Используйте защитные меры во всех версиях вашего API, а не только на текущей производственной версии.

Чтобы предотвратить уязвимости массового распределения, добавьте в список разрешений свойства, которые пользователь может обновлять, и блокируйте чувствительные свойства, которые не должны обновляться пользователем.

Чтобы предотвратить загрязнение параметров на сервере, используйте список разрешений для определения символов, не требующих кодирования, и убедитесь, что весь остальной пользовательский ввод закодирован до включения в серверный запрос. Также убедитесь, что все вводные данные соответствуют ожидаемому формату и структуре.