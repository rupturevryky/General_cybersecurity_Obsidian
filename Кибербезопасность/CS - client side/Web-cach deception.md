Важно сначала отключить `URL-encode characters`.

**Payload:**
```
!
"
#
$
%
&
'
(
)
*
+
,
-
.
/
:
;
<
=
>
?
@
[
\
]
^
_
`
{
|
}
~
%00
%0A
%09
%21
%22
%23
%24
%25
%26
%27
%28
%29
%2A
%2B
%2C
%2D
%2E
%2F
%3A
%3B
%3C
%3D
%3E
%3F
%40
%5B
%5C
%5D
%5E
%5F
%60
%7B
%7C
%7D
%7E
..%2f
aaa/..%2f
%2f%2e%2e%2f
;%2f%2e%2e%2f
%23%2f%2e%2e%2f
/robots.txt
/index.html
/favicon.ico
```
Часто кэшируемые директории:
``` 
/static
/assets
/scripts
/images
/image
/resources
/scripts/..%2f
/images/..%2f
/image/..%2f
/static/..%2fprofile
/assets/js/
/assets/..%2fjs/
%23%2f%2e%2e%2f
%23%2f%2e%2e%2fstatic
%23%2f%2e%2e%2fassets
%23%2f%2e%2e%2fscripts
%23%2f%2e%2e%2fimages
%23%2f%2e%2e%2fimage
%23%2f%2e%2e%2fresources
```

---

## Веб-кэши

Веб-кэш — это система, расположенная между исходным сервером и пользователем. Когда клиент запрашивает статический ресурс, запрос сначала направляется в кэш. Если кэш не содержит копии ресурса (так называемого пропуском кэша), запрос пересылается на исходный сервер, который обрабатывает и отвечает на запрос. Ответ затем отправляется в кэш перед отправкой пользователю. Кэш использует заранее настроенный набор правил для определения сохранения ответа.

Когда в будущем выполняется запрос на тот же статический ресурс, кэш напрямую передаёт сохранённую копию ответа пользователю (это называется кэш-хитом).![[Pasted image 20251224184455.png]]

Кэширование стало распространённым и важным аспектом доставки веб-контента, особенно благодаря широкому использованию сетей доставки контента (CDN), которые используют кэширование для хранения копий контента на распределённых серверах по всему миру. CDN ускоряют доставку, предоставляя контент с сервера, ближайшего к пользователю, сокращая время загрузки за счёт минимизации расстояния, которое проходят данные.

---

## Ключи кэша

Когда кэш получает HTTP-запрос, он должен решить, может ли кэшированный ответ напрямую подавать или перенаправлять запрос на исходный сервер. Кэш принимает это решение, генерируя «ключ кэша» из элементов HTTP-запроса. Обычно это включает путь URL и параметры запроса, но также может включать различные другие элементы, такие как заголовки и тип контента.

Если ключ кэша входящего запроса совпадает с ключом предыдущего запроса, кэш считает их эквивалентными и предоставляет копию кэшированного ответа.

> **Примечание**
>
>Чтобы узнать, как управлять ключами кэша для внедрения вредоносного контента в кэш, смотрите нашу тему Академии отравления веб-кэшом.

---

## Правила кэша

Правила кэша определяют, что можно кэшировать и как долго. Правила кэша часто настраиваются для хранения статических ресурсов, которые обычно редко меняются и используются на нескольких страницах. Динамический контент не кэшируется, так как он с большей вероятностью содержит конфиденциальную информацию, что гарантирует, что пользователи получают последние данные напрямую с сервера.

Атаки на обман веб-кэша эксплуатируют применение правил кэша, поэтому важно знать о некоторых типах правил, особенно основанных на определённых строках в URL-пути запроса. Например:

- Правила статических расширений файлов — эти правила соответствуют расширению файла запрашиваемого ресурса, например `.css`, для стилей или `.js` JavaScript-файлов.
- Статические правила каталога — эти правила совпадают со всеми путями URL, начинающимися с определённого префикса. Они часто используются для нацеливания на конкретные каталоги, содержащие только статические ресурсы, например `/static` или `/assets`.
- Правила имён файлов — Эти правила сопоставляют имена конкретных файлов с целевые файлы, которые универсально необходимы для веб-операций и редко меняются, такие как `robots.txt` и `favicon.ico`.

Кэши также могут реализовывать пользовательские правила на основе других критериев, таких как параметры URL или динамический анализ.

---

## Построение атаки с обманом веб-кэша

В общем, создание базовой атаки на обман веб-кэша включает следующие шаги:

1. Определите целевую конечную точку `GET`, которая возвращает динамический ответ с конфиденциальной информацией. Просмотрите ответы в Burp, так как часть чувствительной информации может быть невидима на отрисованной странице. Сосредоточьтесь на конечных точках, поддерживающих `OPTIONS`, или `HEAD` методы, поскольку запросы, изменяющие состояние исходного сервера, обычно не кэшированы.
2. Выявите несоответствие в том, как кэш и исходный сервер парсируют путь URL. Это может быть несоответствие в том, как они:
    - Сопоставьте URL с ресурсами.
    - Обрабатываются символы разделителей.
    - Нормализуются пути.
3. Создайте вредоносный URL, который использует это несоответствие, чтобы обмануть кэш и заставить его хранить динамический ответ. Когда жертва обращается к URL, её ответ сохраняется в кэше. Используя Burp, вы можете отправить запрос на тот же URL, чтобы получить кэшированный ответ с данными жертвы. Избегайте этого напрямую в браузере, так как некоторые приложения перенаправляют пользователей без сессии или аннулируют локальные данные, что может скрыть уязвимость.

Мы рассмотрим различные подходы к созданию атаки на обман веб-кэша.

---

### Использование кэш-разрушителя **Param Miner**

При тестировании на несоответствия и создании эксплойта для обмана веб-кэша убедитесь, что каждый отправленный вами запрос содержит отдельный ключ кэша. В противном случае вы можете получить кэшированные ответы, что повлияет на результаты теста.

Поскольку и URL-путь, и любые параметры запроса обычно включены в ключ кэша, вы можете изменить ключ, добавив строку запроса в путь и меняя её каждый раз при отправке запроса. Автоматизируйте этот процесс с помощью расширения Param Miner. Для этого после установки расширения нажмите на верхнее меню **Param Miner > меню Настройки**, затем выберите Add **dynamic cachebuster**. Теперь Burp добавляет уникальную строку запроса к каждому вашему запросу. Добавленные строки запросов можно просмотреть во **вкладке Logger**.

---

### Обнаружение кэшированных ответов

Во время тестирования крайне важно уметь выявлять кэшированные ответы. Для этого посмотрите заголовки ответов и время отклика.

Различные заголовки ответа могут указывать на кэширование. Например:

- Заголовок `X-Cache` содержит информацию о том, был ли ответ предоставлен из кэша. Типичные значения включают: 
    - `X-Cache: hit` - Ответ был вручён из кэша.
    - `X-Cache: miss` - Кэш не содержал ответа на ключ запроса, поэтому он был получен с исходного сервера. В большинстве случаев ответ кэшируется. Чтобы подтвердить это, отправьте запрос снова, чтобы проверить, обновится ли значение для достижения.
    - `X-Cache: dynamic` - Исходный сервер динамически генерировал контент. Обычно это означает, что отклик не подходит для кэширования.
    - `X-Cache: refresh` - Кэшированный контент был устаревшим и требовал обновления или повторной проверки.
- Заголовок `Cache-Control` может содержать директиву, указывающую на кэширование, например `public`, с коэффициентом `max-age` выше `0`. Обратите внимание, что это лишь указывает на кэшируемость ресурса. Это не всегда свидетельствует о кэшировании, так как кэш иногда можно переопределять этот заголовок.

Если вы заметили большую разницу во времени отклика на тот же запрос, это также может указывать на то, что более быстрый ответ поступает из кэша.

---

### Использование правил кэша статических расширений

Правила кэша часто нацелены на статические ресурсы, сопоставляя распространённые расширения файлов, такие как `.css` или `.js`. Это поведение по умолчанию в большинстве CDN. 

Если существуют расхождения в том, как кэш и исходный сервер отображают путь URL к ресурсам или используют разделители, злоумышленник может создать запрос на динамический ресурс с помощью статического расширения, которое игнорируется исходным сервером, но рассматривается кэшом.

---

### Расхождения в картографировании путей

Отображение путей URL — это процесс связывания URL-путей с ресурсами на сервере, такими как файлы, скрипты или выполнение команд. Существует множество различных стилей картирования, используемых разными фреймворками и технологиями. Два распространённых стиля — традиционное сопоставление URL и RESTful URL-сопоставление.

Традиционное отображение URL представляет собой прямой путь к ресурсу, расположенному в файловой системе. Вот типичный пример:

`http://example.com/path/in/filesystem/resource.html`

- `http://example.com` Указывает на сервер.
- `/path/in/filesystem/` представляет путь к каталогу в файловой системе сервера.
- `resource.html` это конкретный файл, к которому обращаются.

В отличие от этого, URL-адреса в стиле REST не совпадают напрямую с физической структурой файла. Они абстрагируют пути файлов в логические части API:

`http://example.com/path/resource/param1/param2`

- `http://example.com` Указывает на сервер.
- `/path/resource/` — это конечная точка, представляющая ресурс.
- `param1` и `param2` — это параметры пути, используемые сервером для обработки запроса.

Расхождения в том, как кэш и исходный сервер отображают путь URL к ресурсам, могут привести к уязвимостям обмана веб-кэша. Рассмотрим следующий пример:

`http://example.com/user/123/profile/wcd.css`

- Исходный сервер, использующий отображение URL в стиле REST, может интерпретировать это  как запрос к конечной точке `/user/123/profile` и возвращать информацию о профиле пользователя `123`, игнорируя `wcd.css` как незначительный параметр.
- Кэш, использующий традиционное отображение URL-адресов, может рассматривать это как запрос к файлу `wcd.css`, расположенному в каталоге `/profile/user/123`. Он интерпретирует путь URL как `/user/123/profile/wcd.css`. Если кэш настроен на хранение ответов на запросы, где путь заканчивается на `.css`, он будет кэшировать и передавать информацию профиля как CSS-файл.

---

### Использование расхождений в отображении путей

Чтобы проверить, как исходный сервер отображает путь URL с ресурсами, добавьте произвольный сегмент пути к URL вашей целевой конечной точки. Если ответ по-прежнему содержит те же чувствительные данные, что и базовый, это означает, что исходный сервер абстрагирует путь URL и игнорирует добавленный сегмент. Например если при модификации `/api/orders/123` к `/api/orders/123/foo` всё равно возвращается информация о заказе. 

Чтобы проверить, как кэш сопоставляет путь URL с ресурсами, нужно изменить путь, чтобы попытаться соответствовать правилу кэша, добавив статическое расширение. Например, обновите `/api/orders/123/foo` до `/api/orders/123/foo.js`. Если ответ кэширован, это указывает: 

- Что кэш интерпретирует полный путь URL с помощью статического расширения.
- Что существует правило кэша для хранения ответов на запросы, заканчивающиеся на `.js`.

Кэши могут иметь правила, основанные на конкретных статических расширениях. Попробуйте различные расширения, включая `.css`, `.ico`, и `.exe`. 

Затем можно создать URL, который возвращает динамический ответ, хранящийся в кэше. Обратите внимание, что эта атака ограничивается конкретной конечной точкой, которую вы тестировали, так как исходный сервер часто использует разные правила абстракции для разных конечных точек.

> **Примечание**
>
>Burp Scanner автоматически обнаруживает уязвимости, связанные с обманом веб-кэша, вызванные расхождениями в мапинге путей во время аудитов. Вы также можете использовать Web Cache Deception Scanner BApp для обнаружения неправильно настроенных веб-кэшей.

---

### Расхождения разделителей

Разделители определяют границы между различными элементами в URL. Использование символов и строк в качестве разделителей обычно стандартизировано. Например, обычно `?` используется для отделения пути URL от строки запроса. Однако, поскольку URI RFC довольно разрешителен, вариации между разными фреймворками или технологиями всё ещё происходят. 

Расхождения в том, как кэш и исходный сервер используют символы и строки в качестве разделителей, могут привести к уязвимостям обмана веб-кэша. Рассмотрим пример `/profile;foo.css`: 

- Фреймворк Java Spring использует символ `;` для добавления параметров, известных как матричные переменные. Исходный сервер, использующий Java Spring, будет интерпретировать `;` как разделитель. Он урезает путь после `/profile` и возвращает информацию о профиле. 
- Большинство других фреймворков не используют `;` как разделитель. Поэтому кэш, не использующий Java Spring, скорее всего, будет интерпретировать `;` и всё последующее как часть пути. Если в кэше есть правило хранения ответов на запросы, заканчивающиеся на `.css`, он может кэшировать и передавать информацию профиля как CSS-файл. 

То же самое касается и других символов, которые используются непоследовательно между фреймворками или технологиями. Рассмотрим запросы к исходному серверу с фреймворком Ruby on Rails, который использует `.` в качестве разделителя для указания формата ответа: 

- `/profile` - Этот запрос обрабатывается стандартным HTML-формататором, который возвращает информацию о профиле пользователя.
- `/profile.css` - Этот запрос распознается как расширение CSS. Форматера CSS нет, поэтому запрос не принимается, и ошибка возвращается.
- `/profile.ico` - Этот запрос использует расширение `.ico`, которое не распознается Ruby on Rails. Стандартный HTML-форматировщик обрабатывает запрос и возвращает информацию пользовательского профиля. В этой ситуации, если кэш настроен на хранение ответов на запросы, заканчивающиеся на `.ico`, он будет кэшировать и передавать информацию профиля как статический файл.

Закодированные символы также иногда могут использоваться в качестве разделителей. Например, рассмотрим запрос `/profile%00foo.js`: 

- Сервер OpenLiteSpeed использует закодированный нулевый символ `%00` в качестве разделителя. Исходный сервер, использующий OpenLiteSpeed, интерпретирует путь как `/profile`. 
- Большинство других фреймворков отвечают ошибкой, если `%00` указан в URL. Однако, если кэш использует Akamai или Fastly, он будет интерпретировать `%00` и всё последующее как путь. 

---

### Использование расхождений между разделителями

Возможно, вы сможете использовать несоответствие разделителей, чтобы добавить статическое расширение к пути, который видит кэш, но не исходный сервер. Для этого нужно определить символ, который используется в качестве разделителя на сервере исходного состава, но не в кэше.

Во-первых, найдите символы, которые используются в качестве разделителей на исходном сервере. Начните этот процесс с добавления произвольной строки в URL вашей целевой конечной точки `/settings/users/list`. Например, модифицировать её на `/settings/users/listaaa`. Вы будете использовать этот ответ как ориентир, когда начнёте тестировать разделительные символы. 

> **Примечание**
>
>Если ответ идентичен исходному, это означает, что запрос перенаправляется. Вам нужно выбрать другую конечную точку для тестирования.

Далее добавьте возможный разделительный символ между исходным путём и произвольной строкой, например `/settings/users/list;aaa`: 

- Если ответ идентичен базовому ответу, это указывает на то, что символ `;` используется как разделитель и исходный сервер интерпретирует путь как `/settings/users/list`. 
- Если ответ на путь совпадает с произвольной строкой, это означает, что символ `;` не используется как разделитель, и исходный сервер интерпретирует путь как `/settings/users/list;aaa`.

Когда вы определите разделители, используемые исходным сервером, проверьте, используются ли они кэшом. Для этого добавьте статическое расширение в конце пути. Если ответ кэширован, это указывает:

- Что кэш не использует разделитель и интерпретирует полный путь URL с помощью статического расширения.
- Что существует правило кэша для хранения ответов на запросы, заканчивающиеся на `.js`.

Обязательно протестируйте все ASCII-символы и ряд распространённых расширений, включая `.css`, `.ico`, и `.exe`. Используйте Burp Intruder, чтобы быстро протестировать этих символы. Чтобы предотвратить кодирование символов разделителя Burp Intruder, отключите автоматическое кодирование символов Burp Intruder в **разделе кодировки Payload** на боковой **панели Payloads**. 

https://portswigger.net/web-security/web-cache-deception/wcd-lab-delimiter-list

Затем можно создать эксплойт, который активирует правило кэша статического расширения. Например, рассмотрим полезную нагрузку `/settings/users/list;aaa.js`. Исходный сервер использует `;` в качестве разделителя: 

- Кэш интерпретирует путь так: `/settings/users/list;aaa.js`
- Исходный сервер интерпретирует путь как: `/settings/users/list`

Исходный сервер возвращает динамическую информацию о профиле, которая хранится в кэше.

Поскольку разделители обычно используются стабильно внутри каждого сервера, эту атаку часто можно применять на разных конечных точках.

> **Примечание**
>
>Некоторые символы разделителя могут быть обработаны браузером жертвы до пересылки запроса в кэш. Это означает, что некоторые разделители нельзя использовать в эксплойте. Например, браузеры кодируют символы по URL, такие как `{`, `}`, `<` и `>`, и используют `#` для усечения пути. 

Если кэш или исходный сервер декодируют эти символы, возможно использовать закодированную версию в эксплойте.

---

### Расхождения в декодировании разделителя

Иногда веб-сайтам необходимо отправлять данные по URL, содержащие символы с особым значением внутри URL, например, разделители. Чтобы эти символы интерпретировались как данные, их обычно кодируют. Однако некоторые парсеры декодируют определённые символы до обработки URL. Если декодируется символ-разделитель, его можно рассматривать как разделитель, усекая путь URL.

Различия в том, какие символы разделителя декодируются кэшом и сервером исходного источника, могут привести к расхождениям в интерпретации пути URL, даже если оба используют одни и те же символы в качестве разделителей. Рассмотрим пример `/profile%23wcd.css`, где `#` используется символ, закодированный URL: 

- Исходный символ `%23` декодирует в `#`. Здесь `#` использует как разделитель, интерпретирует путь как `/profile` и возвращает информацию о профиле. 
- Кэш также использует символ `#` как разделитель, но не декодирует `%23`. Он интерпретирует путь как `/profile%23wcd.css`. Если для расширения `.css` есть правило кэша, ответ кэшируется. 

Кроме того, некоторые серверы кэша могут декодировать URL и затем пересылать запрос с декодированными символами. Другие сначала применяют правила кэша на основе закодированного URL, затем декодируют URL и пересылают его на следующий сервер. Такое поведение также может приводить к расхождениям в интерпретации URL-пути кэшем и исходным сервером. Рассмотрим пример `/myaccount%3fwcd.css`: 

- Кэш-сервер применяет правила кэша на основе закодированного пути `/myaccount%3fwcd.css` и решает хранить ответ, так как для расширения `.css` действует правило кэша. Затем он декодирует `%3f` в `?` и пересылает переписанный запрос на исходный сервер. 
- Исходный сервер получает запрос `/myaccount?wcd.css`. Он использует символ `?` как разделитель, поэтому путь интерпретирует как `/myaccount`. 

Возможно, вы сможете воспользоваться расхождением в декодировании, используя закодированный разделитель для добавления статического расширения к пути, который видит кэш, но не исходный сервер.

Используйте ту же методику тестирования, что и для выявления и эксплуатации расхождений в разделителях, но используйте различные закодированные символы. Убедитесь, что вы также протестировали закодированные непечатаемые символы, особенно `%00`, `%0A`, и `%09`. Если эти символы декодированы, они также могут обрезать путь к URL. 

---

### Использование статических правил кэша каталогов

Обычно веб-серверы хранят статические ресурсы в определённых каталогах. Правила кэша часто таргетируют эти каталоги, сопоставляя определённые префиксы пути URL, такие как `/static`, `/assets`, `/scripts`, или `/images`. Эти правила также могут быть уязвимы к обману веб-кэша. 

> **Примечание**
>
>Чтобы использовать статические правила кэша каталогов, вам нужно понимать основы атак по путям. Для получения дополнительной информации смотрите нашу тему Path traversal Academy.

---

### Расхождения нормализации

Нормализация включает преобразование различных представлений путей URL в стандартизированный формат. Иногда это включает декодирование закодированных символов и разрешение точечных сегментов, но это значительно варьируется от парсера к парсеру.

Расхождения в том, как кэш и исходный сервер нормализуют URL, могут позволить злоумышленнику построить полезную нагрузку для прохождения пути, которая интерпретируется каждым парсером по-разному. Рассмотрим пример `/static/..%2fprofile`: 

- Исходный сервер, который декодирует косые черты и разрешает точечные сегменты, нормализует путь к `/profile` и возвращает информацию о профиле. 
- Кэш, не разрешающий точечные сегменты или косые черты, интерпретирует путь как `/static/..%2fprofile`. Если кэш хранит ответы на запросы с префиксом `/static`, он будет кэшировать и передавать информацию профиля. 

Как показано в приведённом выше примере, каждый точечный сегмент в последовательности прохождения пути должен быть закодирован. В противном случае браузер жертвы решит проблему до пересылки запроса в кэш. Таким образом, для эксплуатационного расхождения нормализации требуется, чтобы либо кэш, либо исходный сервер декодировали символы в последовательности прохождения пути, а также разрешали точечные сегменты.

---

#### Обнаружение нормализации исходным сервером

Чтобы проверить, как исходный сервер нормализует путь URL, отправьте `POST` запрос к некэшируемому ресурсу с последовательностью прохождения пути и произвольным каталогом в начале пути. Чтобы выбрать некэшируемый ресурс, ищите не идемпотентный метод, например `/profile` изменим на `/aaa/..%2fprofile`: 

- Если ответ совпадает с базовым ответом и возвращает информацию о профиле, это означает, что путь интерпретирован как `/profile`. Исходный сервер декодирует косую черту и разрешает точечный сегмент.
- Если ответ не совпадает с базовым ответом, например, возвращает сообщение об ошибке `404`, это означает, что путь интерпретирован как `/aaa/..%2fprofile`. Исходный сервер либо не декодирует косую черту, либо разрешает точечный сегмент.

> **Примечание**
>
>При тестировании нормализации начинайте с кодирования только второй косой черты в точечном сегменте. Это важно, потому что некоторые CDN включают `/` после статического префикса каталога.

Можно также попробовать закодировать полную последовательность прохождения пути или закодировать точку вместо косой черты. Иногда это влияет на декодирование последовательности парсером.

Можно использовать несколько разных методов, чтобы проверить, как кэш нормализует путь. Начните с определения потенциальных статических каталогов. В **истории Proxy > HTTP** ищите запросы с общими статическими префиксами и кэшированными ответами. Сосредоточьтесь на статических ресурсах, установив фильтр истории HTTP так, чтобы показывать сообщения только с 2xx ответами и типами скриптов, изображений и CSS MIME.

Затем вы можете выбрать запрос с кэшированным ответом и отправить запрос повторно с последовательностью обхода пути и произвольным каталогом в начале статического пути. Выберите запрос с ответом, содержащим доказательства кэширования. Например `/aaa/..%2fassets/js/stockCheck.js`: 

- Если ответ больше не кэшируется, это указывает на то, что кэш не нормализует путь до того, как отметит его на конечную точку. Он показывает, что существует правило кэша, основанное на префиксе `/assets`.
- Если ответ всё ещё кэшируется, это может указывать на то, что кэш нормализовал путь к `/assets/js/stockCheck.js`.

---

Вы также можете добавить последовательность прохождения путей после префикса каталога. Например, изменим `/assets/js/stockCheck.js` на `/assets/..%2fjs/stockCheck.js`: 

- Если ответ больше не кэшируется, это означает, что кэш декодирует косую черту и разрешает точечный сегмент во время нормализации, интерпретируя путь как `/js/stockCheck.js`. Он показывает, что существует правило кэша, основанное на префиксе `/assets`.
- Если ответ всё ещё кэширован, это может указывать на то, что кэш не расшифровал косую черту или не разрешил точечный сегмент, интерпретируя путь как `/assets/..%2fjs/stockCheck.js`.

---

Обратите внимание, что в обоих случаях ответ может быть кэширован из-за другого правила кэша, например, основанного на расширении файла. Чтобы подтвердить, что правило кэша основано на статическом каталоге, замените путь после префикса каталога на произвольную строку. Например `/assets/aaa`. Если ответ всё ещё кэширован, это подтверждает, что правило кэша основано на префиксе `/assets`. Обратите внимание, что если ответ, похоже, не кэширован, это не обязательно исключает правило статического кэша каталогов, так как иногда ответы `404` не кэшированы. 

> **Примечание**
>
> Возможно, вы не сможете точно определить, расшифровывает ли кэш точечные сегменты и путь URL без попытки использовать эксплойт.

---

Если исходный сервер разрешает закодированные точечные сегменты, а кэш — нет, вы можете попытаться воспользоваться этим несоответствием, построив полезную нагрузку по следующей структуре:

`/<static-directory-prefix>/..%2f<dynamic-path>`

Например, рассмотрим полезную нагрузку : `/assets/..%2fprofile`

- Кэш интерпретирует путь так: `/assets/..%2fprofile`
- Исходный сервер интерпретирует путь как: `/profile`

Исходный сервер возвращает динамическую информацию о профиле, которая хранится в кэше.

---

Если сервер кэша разрешает закодированные точечные сегменты, а исходный сервер — нет, вы можете попытаться воспользоваться этим несоответствием, построив полезную нагрузку по следующей структуре:

`/<dynamic-path>%2f%2e%2e%2f<static-directory-prefix>`

> **Примечание**
>
>При использовании нормализации кэш-сервером кодируют все символы последовательности прохождения пути. Использование закодированных символов помогает избежать неожиданного поведения при использовании делимитеров, и нет необходимости использовать незакодированную слэш после статического префикса каталога, так как кэш занимается декодированием.

В этой ситуации одного прохождения пути недостаточно для эксплойта. Например, рассмотрим, как кэш и исходный сервер интерпретируют полезную нагрузку `/profile%2f%2e%2e%2fstatic`: 

- Кэш интерпретирует путь так: `/static`
- Исходный сервер интерпретирует путь как: `/profile%2f%2e%2e%2fstatic`

Исходный сервер, скорее всего, выдаст сообщение об ошибке вместо информации о профиле.

---

Чтобы воспользоваться этим несоответствием, нужно также определить разделитель, который используется исходным сервером, но не кэш. Проверьте возможные разделители, добавив их в полезную нагрузку после динамического пути:

- Если исходный сервер использует разделитель, он обрезает путь URL и вернёт динамическую информацию.
- Если кэш не использует разделитель, он разрешит путь и кэширует ответ.

Например, рассмотрим полезную нагрузку `/profile;%2f%2e%2e%2fstatic`. Исходный сервер использует `;` в качестве разделителя: 

- Кэш интерпретирует путь так: `/static`
- Исходный сервер интерпретирует путь как: `/profile`

Исходный сервер возвращает динамическую информацию о профиле, которая хранится в кэше. Таким образом, вы можете использовать эту полезность для эксплойта.

---

### Использование правил кэша имён файлов

Некоторые файлы, такие как `robots.txt`, `index.html`, и `favicon.ico` являются распространёнными файлами, находящимися на веб-серверах. Их часто кэшируют из-за редких изменений. Правила кэша нацелены на эти файлы, соответствуя точной строке имени файла. 

Чтобы определить, существует ли правило кэша имён файла, отправьте `GET` запрос на возможный файл и проверьте, кэширован ли ответ. 

---

Чтобы проверить, как исходный сервер нормализует путь URL, используйте тот же метод, что и для статических правил кэша каталогов. Для получения дополнительной информации см. раздел «Обнаружение нормализации исходным сервером».

Чтобы проверить, как кэш нормализует путь URL, отправьте запрос с последовательностью прохождения пути и произвольным каталогом перед именем файла. Например: `/profile%2f%2e%2e%2findex.html`

- Если ответ кэширован, это означает, что кэш нормализует путь к `/index.html`.
- Если ответ не кэширован, это означает, что кэш не расшифровывает косую черту и не разрешает точечный сегмент, интерпретируя путь как `/profile%2f%2e%2e%2findex.html`.

Поскольку ответ кэшируется только если запрос совпадает с именем файла, можно воспользоваться только несоответствием, когда сервер кэша разрешает закодированные точечные сегменты, а исходный сервер — нет. Используйте тот же метод, что и для статических правил кэша каталогов — просто замените статический префикс каталога на имя файла. Для получения дополнительной информации см. раздел «Использование нормализации кэш-сервером».

---

# Лабораторные

---

## Lab: Exploiting path mapping for web cache deception

https://portswigger.net/web-security/learning-paths/web-cache-deception/wcd-using-path-mapping-discrepancies/web-cache-deception/lab-wcd-exploiting-path-mapping

```html
<script>document.location='https://*.web-security-academy.net/my-account/.ico'</script>
```

---

## Lab: Exploiting path delimiters for web cache deception

https://portswigger.net/web-security/learning-paths/web-cache-deception/wcd-using-delimiter-discrepancies/web-cache-deception/lab-wcd-exploiting-path-delimiters

```html
<script>document.location='https://*.web-security-academy.net/my-account;.js'</script>
```

---

## Lab: Exploiting origin server normalization for web cache deception

https://portswigger.net/web-security/learning-paths/web-cache-deception/wcd-using-normalization-discrepancies/web-cache-deception/lab-wcd-exploiting-origin-server-normalization

```html
<script>document.location='https://*.web-security-academy.net/resources/..%2fmy-account'</script>
```

---

## Lab: Exploiting cache server normalization for web cache deception

[Обман веб-кэша — PortSwigger](https://portswigger.net/web-security/learning-paths/web-cache-deception/wcd-using-normalization-discrepancies/web-cache-deception/lab-wcd-exploiting-cache-server-normalization)

```html
<script>document.location='https://*.web-security-academy.net/my-account%23%2f%2e%2e%2fresources'</script>
```

---

## Предотвращение уязвимостей обмана веб-кэша

Вы можете предпринять ряд шагов для предотвращения уязвимостей обмана в веб-кэше:

- Всегда используйте заголовки `Cache-Control` для обозначения динамических ресурсов, заданных директивами `no-store` и `private`.
- Настройте настройки CDN так, чтобы правила кэширования не переопределяли заголовок `Cache-Control`.
- Активируйте любую защиту вашего CDN от атак с обманом веб-кэша. Многие CDN позволяют установить правило кэша, которое проверяет, совпадает ли ответ `Content-Type` с расширением URL-файла запроса. Например, защита Cache Deception от Cloudflare.
- Проверьте, нет ли расхождений в том, как исходный сервер и кэш интерпретируют пути URL.